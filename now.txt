diff --git a/docs/project-overview.md b/docs/project-overview.md
new file mode 100644
index 0000000..10dd866
--- /dev/null
+++ b/docs/project-overview.md
@@ -0,0 +1,229 @@
+# Web Video Editor Project Overview
+
+## Core Flow
+
+1. **Media Upload & Management**
+   - Entry: MediaSidebar.js
+   - Flow: User uploads video files → Files stored in state → Displayed in MediaBin
+   - Key Components:
+     - `MediaSidebar`: Handles file upload UI and timeline project management
+     - `MediaBin`: Displays uploaded media files
+     - State: `mediaFiles` in App.js
+
+2. **Clip Selection & Preview**
+   - Entry: BinViewer.js
+   - Flow: User selects media → Preview in BinViewer → Can trim/select region
+   - Key Components:
+     - `BinViewer`: Video preview and trim controls
+     - `BinViewerSection`: Container for viewer and controls
+     - State: `selectedBinClip` in App.js
+
+3. **Timeline Management**
+   - Entry: Timeline/index.js
+   - Flow: Add clips → Arrange on timeline → Modify positions/durations
+   - Key Components:
+     - `Timeline`: Main timeline editor component
+     - `TimelineClip`: Individual clip representation
+     - `TimelineControls`: Zoom and timeline controls
+     - State: `timelineClips` in App.js
+
+4. **State Management**
+   - Entry: useTimelineStateManager.js
+   - Flow: Manages timeline state → Handles modifications → Saves/loads projects
+   - Key Functions:
+     - `saveTimelineProject`: Saves current timeline state
+     - `loadTimelineProject`: Loads saved timeline
+     - `processTimelineClips`: Processes clips for loading
+     - State: Local storage for persistence
+
+## Detailed Component Breakdown
+
+### Media Management
+```typescript
+// MediaSidebar.js
+interface MediaSidebarProps {
+  files: File[];
+  onFileUpload: (file: File) => void;
+  onFileSelect: (file: File) => void;
+  timelineProjects: {
+    selected: string | null;
+    onSave: (name: string) => void;
+    onLoad: (name: string) => void;
+    onDelete: (name: string) => void;
+  };
+}
+```
+
+### Timeline Editing
+```typescript
+// Timeline/index.js
+interface TimelineProps {
+  clips: TimelineClip[];
+  onClipsChange: (clips: TimelineClip[]) => void;
+  selectedClipId: string;
+  onClipSelect: (id: string) => void;
+}
+```
+
+### State Management
+```typescript
+// useTimelineStateManager.js
+interface TimelineState {
+  clips: TimelineClip[];
+  metadata: {
+    scale: number;
+    selectedClipId: string | null;
+  };
+  settings: {
+    effects: Record<string, Effect>;
+  };
+}
+```
+
+## Data Flow Diagram
+
+```
+Upload → MediaBin
+   ↓
+Select → BinViewer
+   ↓
+Add to Timeline → TimelineClip
+   ↓
+Edit/Arrange → Timeline
+   ↓
+Save/Export → TimelineStateManager
+```
+
+## Key Features & Implementation
+
+1. **Video Upload**
+   - Component: `MediaSidebar`
+   - Handler: `handleFileUpload`
+   - Storage: In-memory state + file references
+
+2. **Clip Selection**
+   - Component: `BinViewer`
+   - Handler: `handleFileSelect`
+   - State: `selectedBinClip`
+
+3. **Timeline Operations**
+   - Move: `handleMoveStart`, `handleMoving`, `handleMoveEnd`
+   - Resize: `handleResizeStart`, `handleResizing`, `handleResizeEnd`
+   - Delete: Context menu + keyboard delete
+
+4. **Project Management**
+   - Save: `saveTimelineProject` (localStorage)
+   - Load: `loadTimelineProject` (with media validation)
+   - Export: `exportTimelineData` (JSON download)
+
+## State Structure
+
+```javascript
+{
+  timeline: {
+    clips: [{
+      id: string;
+      source: {
+        startTime: number;
+        endTime: number;
+        duration: number;
+      };
+      metadata: {
+        timeline: {
+          start: number;
+          end: number;
+          track: number;
+        };
+        playback: {
+          start: number;
+          end: number;
+        };
+      };
+    }];
+    settings: {
+      scale: number;
+      effects: Object;
+    };
+  }
+}
+```
+
+## Important Considerations
+
+1. **Time Management**
+   - Source time vs Timeline time
+   - Maintaining original durations
+   - Handling trimmed sections
+
+2. **State Persistence**
+   - Project saving/loading
+   - Media file references
+   - Timeline positions
+
+3. **Performance**
+   - Thumbnail generation
+   - Cache management
+   - Render optimization
+
+4. **Error Handling**
+   - Missing media files
+   - Invalid timeline states
+   - Load/save failures
+
+## Development Guidelines
+
+1. Use TypeScript for new components
+2. Follow existing patterns for state updates
+3. Maintain immutable state updates
+4. Document complex operations
+5. Add error boundaries for stability
+
+## Performance Considerations
+
+### Video Playback
+- Preload next clip
+- Unload distant clips
+- Use requestAnimationFrame
+- Hardware acceleration
+
+### Timeline Rendering
+- Virtualize clip rendering
+- Optimize thumbnail generation
+- Cache calculated positions
+
+### State Management
+- Immutable updates
+- Selective rerenders
+- Batch timeline updates
+
+## Error Handling
+
+### Media Errors
+- Missing files
+- Corrupt video
+- Unsupported format
+
+### Timeline Errors
+- Invalid positions
+- Overlapping clips
+- Save/load failures
+
+## Testing Strategy
+
+### Unit Tests
+- Timeline calculations
+- State transitions
+- File handling
+
+### Integration Tests
+- Clip operations
+- Timeline playback
+- Save/load cycle
+
+### Performance Tests
+- Large timeline handling
+- Multiple video playback
+- Memory management
+
+with 
+# Web Video Editor Project Overview
\ No newline at end of file
diff --git a/package-lock.json b/package-lock.json
index 0c05a96..644e5e9 100644
--- a/package-lock.json
+++ b/package-lock.json
@@ -18,6 +18,7 @@
         "@testing-library/react": "^13.4.0",
         "@testing-library/user-event": "^13.5.0",
         "@xzdarcy/react-timeline-editor": "^0.1.9",
+        "axios": "^1.7.7",
         "debug": "^4.3.7",
         "lucide-react": "^0.453.0",
         "react": "^18.3.1",
@@ -25,8 +26,12 @@
         "react-dom": "^18.3.1",
         "react-player": "^2.16.0",
         "react-scripts": "5.0.1",
+        "video-react": "^0.16.0",
         "wavesurfer.js": "^7.8.7",
         "web-vitals": "^2.1.4"
+      },
+      "devDependencies": {
+        "@types/video-react": "^0.15.8"
       }
     },
     "node_modules/@adobe/css-tools": {
@@ -4914,6 +4919,15 @@
       "resolved": "https://registry.npmjs.org/@types/trusted-types/-/trusted-types-2.0.7.tgz",
       "integrity": "sha512-ScaPdn1dQczgbl0QFTeTOmVHFULt394XJgOQNoyVhZ6r2vLnMLJfBPd53SB52T/3G36VI1/g2MZaX0cwDuXsfw=="
     },
+    "node_modules/@types/video-react": {
+      "version": "0.15.8",
+      "resolved": "https://registry.npmjs.org/@types/video-react/-/video-react-0.15.8.tgz",
+      "integrity": "sha512-ZFm57z6bwJ1FWMKAMXyDar0OAQCchals2T4mDG//JXeToW3C2dADI2MzX5y53tFL77Y2QAA1YQZh5XTL1rjiqw==",
+      "dev": true,
+      "dependencies": {
+        "@types/react": "*"
+      }
+    },
     "node_modules/@types/ws": {
       "version": "8.5.12",
       "resolved": "https://registry.npmjs.org/@types/ws/-/ws-8.5.12.tgz",
@@ -5832,6 +5846,29 @@
         "node": ">=4"
       }
     },
+    "node_modules/axios": {
+      "version": "1.7.7",
+      "resolved": "https://registry.npmjs.org/axios/-/axios-1.7.7.tgz",
+      "integrity": "sha512-S4kL7XrjgBmvdGut0sN3yJxqYzrDOnivkBiN0OFs6hLiUam3UPvswUo0kqGyhqUZGEOytHyumEdXsAkgCOUf3Q==",
+      "dependencies": {
+        "follow-redirects": "^1.15.6",
+        "form-data": "^4.0.0",
+        "proxy-from-env": "^1.1.0"
+      }
+    },
+    "node_modules/axios/node_modules/form-data": {
+      "version": "4.0.1",
+      "resolved": "https://registry.npmjs.org/form-data/-/form-data-4.0.1.tgz",
+      "integrity": "sha512-tzN8e4TX8+kkxGPK8D5u0FNmjPUjw3lwC9lSLxxoB/+GtsJG91CO8bSWy73APlgAZzZbXEYZJuxjkHH2w+Ezhw==",
+      "dependencies": {
+        "asynckit": "^0.4.0",
+        "combined-stream": "^1.0.8",
+        "mime-types": "^2.1.12"
+      },
+      "engines": {
+        "node": ">= 6"
+      }
+    },
     "node_modules/axobject-query": {
       "version": "4.1.0",
       "resolved": "https://registry.npmjs.org/axobject-query/-/axobject-query-4.1.0.tgz",
@@ -6508,6 +6545,11 @@
       "resolved": "https://registry.npmjs.org/cjs-module-lexer/-/cjs-module-lexer-1.4.1.tgz",
       "integrity": "sha512-cuSVIHi9/9E/+821Qjdvngor+xpnlwnuwIyZOaLmHBVdXL+gP+I6QQB9VkO7RI77YIcTV+S1W9AreJ5eN63JBA=="
     },
+    "node_modules/classnames": {
+      "version": "2.5.1",
+      "resolved": "https://registry.npmjs.org/classnames/-/classnames-2.5.1.tgz",
+      "integrity": "sha512-saHYOzhIQs6wy2sVxTM6bUDsQO4F50V9RQ22qBpEdCW+I+/Wmke2HOl6lS6dTpdxVhb88/I6+Hs+438c3lfUow=="
+    },
     "node_modules/clean-css": {
       "version": "5.3.3",
       "resolved": "https://registry.npmjs.org/clean-css/-/clean-css-5.3.3.tgz",
@@ -12906,6 +12948,11 @@
       "resolved": "https://registry.npmjs.org/lodash.sortby/-/lodash.sortby-4.7.0.tgz",
       "integrity": "sha512-HDWXG8isMntAyRF5vZ7xKuEvOhT4AhlRt/3czTSjvGUxjYCBVRQY48ViDHyfYz9VIoBkW4TMGQNapx+l3RUwdA=="
     },
+    "node_modules/lodash.throttle": {
+      "version": "4.1.1",
+      "resolved": "https://registry.npmjs.org/lodash.throttle/-/lodash.throttle-4.1.1.tgz",
+      "integrity": "sha512-wIkUCfVKpVsWo3JSZlc+8MB5it+2AN5W8J7YVMST30UrvcQNZ1Okbj+rbVniijTWE6FGYy4XJq/rHkas8qJMLQ=="
+    },
     "node_modules/lodash.uniq": {
       "version": "4.5.0",
       "resolved": "https://registry.npmjs.org/lodash.uniq/-/lodash.uniq-4.5.0.tgz",
@@ -15139,6 +15186,11 @@
         "node": ">= 0.10"
       }
     },
+    "node_modules/proxy-from-env": {
+      "version": "1.1.0",
+      "resolved": "https://registry.npmjs.org/proxy-from-env/-/proxy-from-env-1.1.0.tgz",
+      "integrity": "sha512-D+zkORCbA9f1tdWRK0RaCR3GPv50cMxcrz4X8k5LTSUD1Dkw47mKJEZQNunItRTkWwgtaUSo1RVFRIG9ZXiFYg=="
+    },
     "node_modules/psl": {
       "version": "1.9.0",
       "resolved": "https://registry.npmjs.org/psl/-/psl-1.9.0.tgz",
@@ -17980,6 +18032,22 @@
         "node": ">= 0.8"
       }
     },
+    "node_modules/video-react": {
+      "version": "0.16.0",
+      "resolved": "https://registry.npmjs.org/video-react/-/video-react-0.16.0.tgz",
+      "integrity": "sha512-138NHPS8bmgqCYVCdbv2GVFhXntemNHWGw9AN8iJSzr3jizXMmWJd2LTBppr4hZJUbyW1A1tPZ3CQXZUaexMVA==",
+      "dependencies": {
+        "@babel/runtime": "^7.4.5",
+        "classnames": "^2.2.6",
+        "lodash.throttle": "^4.1.1",
+        "prop-types": "^15.7.2",
+        "redux": "^4.0.1"
+      },
+      "peerDependencies": {
+        "react": "^15.0.0 || ^16.0.0 || ^17.0.0 || ^18.0.0",
+        "react-dom": "^15.0.0 || ^16.0.0 || ^17.0.0 || ^18.0.0"
+      }
+    },
     "node_modules/w3c-hr-time": {
       "version": "1.0.2",
       "resolved": "https://registry.npmjs.org/w3c-hr-time/-/w3c-hr-time-1.0.2.tgz",
diff --git a/package.json b/package.json
index 8fb54c4..f221851 100644
--- a/package.json
+++ b/package.json
@@ -13,6 +13,7 @@
     "@testing-library/react": "^13.4.0",
     "@testing-library/user-event": "^13.5.0",
     "@xzdarcy/react-timeline-editor": "^0.1.9",
+    "axios": "^1.7.7",
     "debug": "^4.3.7",
     "lucide-react": "^0.453.0",
     "react": "^18.3.1",
@@ -20,6 +21,7 @@
     "react-dom": "^18.3.1",
     "react-player": "^2.16.0",
     "react-scripts": "5.0.1",
+    "video-react": "^0.16.0",
     "wavesurfer.js": "^7.8.7",
     "web-vitals": "^2.1.4"
   },
@@ -46,5 +48,8 @@
       "last 1 firefox version",
       "last 1 safari version"
     ]
+  },
+  "devDependencies": {
+    "@types/video-react": "^0.15.8"
   }
 }
diff --git a/src/App.js b/src/App.js
index b3a0862..7d04faf 100644
--- a/src/App.js
+++ b/src/App.js
@@ -1,12 +1,15 @@
-import React, { useState } from 'react';
+import React, { useState, useCallback } from 'react';
 import { ThemeProvider, createTheme, StyledEngineProvider } from '@mui/material/styles';
 import CssBaseline from '@mui/material/CssBaseline';
-import { Box } from '@mui/material';
+import { Box, Snackbar, Alert } from '@mui/material';
 
 // Layout components
 import MainLayout from './components/Layout/MainLayout';
 import EditorLayout from './components/Layout/EditorLayout';
 
+// Chabot
+import ChatBot from './components/Chatbot/ChatBot';
+
 // Viewer components
 import BinViewerSection from './components/Viewers/BinViewerSection';
 import TimelineViewerSection from './components/Viewers/TimelineViewerSection';
@@ -14,6 +17,8 @@ import TimelineViewerSection from './components/Viewers/TimelineViewerSection';
 // Timeline components
 import TimelineSection from './components/Timeline/TimelineSection';
 import TimelineDebug from './components/Timeline/TimelineDebug';
+import { useTimelineStateManager } from './hooks/useTimeline/useTimelineStateManager';
+
 
 
 
@@ -29,42 +34,176 @@ const theme = createTheme({
 });
 
 function App() {
+  // State
   const [mediaFiles, setMediaFiles] = useState([]);
   const [selectedBinClip, setSelectedBinClip] = useState(null);
   const [timelineClips, setTimelineClips] = useState([]);
+  const [notification, setNotification] = useState(null);
+  const [selectedTimelineProject, setSelectedTimelineProject] = useState(null);
+  const [transcripts, setTranscripts] = useState(new Map());
 
-  const handleFileUpload = (file) => {
-    const newFile = { 
-      id: Date.now().toString(), 
-      file: file, 
-      name: file.name,
-      type: file.type,
-      size: file.size 
-    };
-    setMediaFiles(prevFiles => [...prevFiles, newFile]);
+  const [chatMessages, setChatMessages] = useState([]);
+  const [timelineRows, setTimelineRows] = useState([{ rowId: 0, clips: [], lastEnd: 0 }]);
+
+// Add this handler function:
+const handleChatMessage = (message) => {
+  setChatMessages(prev => [...prev, message]);
+};
+
+  // Timeline metadata state
+  const [timelineMetadata, setTimelineMetadata] = useState({
+    scale: 1,
+    selectedClipId: null
+  });
+
+  const showNotification = (message, severity = 'info') => {
+    setNotification({ message, severity });
+  };
+
+  const timelineState = {
+    clips: timelineClips.map(clip => {
+      const metadata = clip.metadata || {};
+      const playback = metadata.playback || {};
+      const timeline = metadata.timeline || {};
+  
+      return {
+        ...clip,
+        timelinePosition: {
+          start: timeline.start,
+          end: timeline.end,
+          duration: timeline.duration,
+          track: timeline.track || 0,
+          playbackStart: playback.start,
+          playbackEnd: playback.end,
+          playbackDuration: playback.duration
+        }
+      };
+    }),
+    totalDuration: timelineClips.reduce((max, clip) => {
+      const end = clip.metadata?.timeline?.end || 0;
+      return Math.max(max, end);
+    }, 0),
+    settings: { 
+      scale: timelineMetadata.scale, 
+      selectedClipId: timelineMetadata.selectedClipId 
+    }
+  };
+  
+
+  // File handling
+  const handleFileUpload = async (file) => {
+    try {
+      if (file.type.startsWith('video/')) {
+        // Handle video file
+        const newFile = { 
+          id: Date.now().toString(), 
+          file: file, 
+          name: file.name,
+          type: file.type,
+          size: file.size 
+        };
+        setMediaFiles(prevFiles => [...prevFiles, newFile]);
+  
+        // Automatically look for matching transcript
+        const transcriptName = file.name.replace(/\.[^/.]+$/, '.json');
+        const hasTranscript = transcripts.has(transcriptName);
+        if (hasTranscript) {
+          showNotification(`Found matching transcript for ${file.name}`, 'success');
+        }
+      } 
+      else if (file.name.endsWith('.json')) {
+        // Handle transcript file
+        try {
+          const text = await file.text();
+          const transcriptData = JSON.parse(text);
+  
+          if (!transcriptData.transcription) {
+            throw new Error('Invalid transcript format');
+          }
+  
+          // Get the corresponding video name
+          const videoName = file.name.replace('.json', '.mp4');
+          const hasVideo = mediaFiles.some(f => f.name === videoName);
+  
+          setTranscripts(prev => new Map(prev).set(file.name, transcriptData));
+          
+          if (hasVideo) {
+            showNotification(`Transcript loaded for ${videoName}`, 'success');
+          } else {
+            showNotification('Transcript loaded. Upload matching video file to use it.', 'info');
+          }
+        } catch (error) {
+          showNotification(`Invalid transcript file: ${error.message}`, 'error');
+        }
+      }
+    } catch (error) {
+      showNotification(`Error uploading file: ${error.message}`, 'error');
+    }
   };
 
   const handleFileSelect = (selectedFile) => {
     setSelectedBinClip(selectedFile);
   };
 
-  const handleAddToTimeline = (clip) => {
-    const newClip = {
-      id: `clip${timelineClips.length + 1}`,
-      file: clip.file,
-      name: clip.file.name,
-      startTime: clip.startTime || 0,
-      endTime: clip.endTime || 0,
-      duration: (clip.endTime || 0) - (clip.startTime || 0)
+  const handleAddToTimeline = (clipData) => {
+    const transcriptName = clipData.name.replace(/\.[^/.]+$/, '.json');
+    const transcriptData = transcripts.get(transcriptName);
+
+    console.log("App.js handleAddToTimeline called with clipData:", clipData);
+
+    // Directly use the existing timeline metadata
+    const enrichedClip = {
+        ...clipData,
+        transcript: transcriptData || null,
+        metadata: {
+            ...clipData.metadata,
+            timeline: {
+                ...clipData.metadata.timeline,
+                track: 0 // Still placing all clips on track 0 for now
+            }
+        }
     };
-    setTimelineClips(prevClips => [...prevClips, newClip]);
-  };
+
+    // Add enriched clip to timelineClips state
+    setTimelineClips((prevClips) => [...prevClips, enrichedClip]);
+};
 
   const handleTimelineClipsChange = (newClips) => {
     setTimelineClips(newClips);
   };
 
- 
+  // Timeline Project Management
+  const { saveTimelineProject, loadTimelineProject, deleteTimelineProject } = useTimelineStateManager({
+    timelineClips,
+    timelineMetadata,
+    mediaFiles,
+    selectedClipId: timelineMetadata.selectedClipId,
+    setTimelineClips,
+    setTimelineMetadata,
+    showNotification
+  });
+
+  // Project management handlers
+  const handleTimelineProjectSave = useCallback((projectName) => {
+    const success = saveTimelineProject(projectName);
+    if (success) {
+      setSelectedTimelineProject(projectName);
+    }
+  }, [saveTimelineProject]);
+
+  const handleTimelineProjectLoad = useCallback((projectName) => {
+    const success = loadTimelineProject(projectName);
+    if (success) {
+      setSelectedTimelineProject(projectName);
+    }
+  }, [loadTimelineProject]);
+
+  const handleTimelineProjectDelete = useCallback((projectName) => {
+    const success = deleteTimelineProject(projectName);
+    if (success && selectedTimelineProject === projectName) {
+      setSelectedTimelineProject(null);
+    }
+  }, [deleteTimelineProject, selectedTimelineProject]);
 
   return (
     <StyledEngineProvider injectFirst>
@@ -75,43 +214,86 @@ function App() {
           selectedBinClip={selectedBinClip}
           onFileUpload={handleFileUpload}
           onFileSelect={handleFileSelect}
+          timelineProjects={{
+            selected: selectedTimelineProject,
+            onSave: handleTimelineProjectSave,
+            onLoad: handleTimelineProjectLoad,
+            onDelete: handleTimelineProjectDelete
+          }}
         >
           <EditorLayout>
             {/* Main Content Area */}
-            <Box sx={{ display: 'flex', flexGrow: 1, gap: 2, p: 2, pb: 0 }}>
-              <BinViewerSection
-                selectedClip={selectedBinClip}
-                onAddToTimeline={handleAddToTimeline}
+            <Box sx={{ display: 'flex', gap: 2, p: 2, pb: 0 }}>
+            <BinViewerSection
+            clips={timelineClips}
+            selectedClip={selectedBinClip}
+            onAddToTimeline={handleAddToTimeline}
+            transcriptData={selectedBinClip ? transcripts.get(selectedBinClip.name.replace(/\.[^/.]+$/, '.json')) : null}
+            timelineState={timelineState}
+            setTimelineRows={setTimelineRows}
+                />
+              <TimelineViewerSection 
+                clips={timelineClips}
+                transcript={transcripts}
+                timelineState={timelineState} 
               />
-              <TimelineViewerSection clips={timelineClips} />
             </Box>
 
             {/* Timeline and Controls Area */}
             <Box sx={{ 
-                mt: 2, 
-                px: 2, 
-                pb: 2, 
-                bgcolor: 'background.default', 
-                borderTop: 1, 
-                borderColor: 'divider',
-                display: 'flex',
-                flexDirection: 'column',
-                gap: 2,
-                '& > *:last-child': {
-                  marginBottom: '20px', // Ensure space at the bottom
-                }
-              }}>
-                <TimelineSection
-                  clips={timelineClips}
-                  onClipsChange={handleTimelineClipsChange}
-                />
-                <TimelineDebug
-                  timelineClips={timelineClips}
-                  selectedBinClip={selectedBinClip}
+              mt: 2, 
+              px: 2, 
+              pb: 2, 
+              bgcolor: 'background.default', 
+              borderTop: 1, 
+              borderColor: 'divider',
+              display: 'flex',
+              flexDirection: 'column',
+              gap: 2,
+              '& > *:last-child': {
+                marginBottom: '20px',
+              }
+            }}>
+              <TimelineSection
+             clips={timelineClips}
+             onClipsChange={handleTimelineClipsChange}
+             timelineState={timelineState}
+             timelineRows={timelineRows}
+             setTimelineRows={setTimelineRows}
                 />
-              </Box>
+              <TimelineDebug
+                timelineClips={timelineClips}
+                selectedBinClip={selectedBinClip}
+              />
+            </Box>
           </EditorLayout>
+          <ChatBot 
+          clips={timelineClips}
+          messages={chatMessages}
+          onSendMessage={handleChatMessage}
+          selectedBinClip={selectedBinClip}
+          transcriptData={selectedBinClip ? transcripts.get(selectedBinClip.name.replace(/\.[^/.]+$/, '.json')) : null}
+          onAddToTimeline={handleAddToTimeline}
+          timelineState={timelineState}
+          timelineRows={timelineRows}
+          setTimelineRows={setTimelineRows}
+          />
         </MainLayout>
+
+        {/* Notifications */}
+        <Snackbar
+          open={!!notification}
+          autoHideDuration={3000}
+          onClose={() => setNotification(null)}
+        >
+          <Alert
+            onClose={() => setNotification(null)}
+            severity={notification?.severity}
+            sx={{ width: '100%' }}
+          >
+            {notification?.message}
+          </Alert>
+        </Snackbar>
       </ThemeProvider>
     </StyledEngineProvider>
   );
@@ -119,3 +301,5 @@ function App() {
 
 export default App;
 
+
+
diff --git a/src/components/Chatbot/Api.js b/src/components/Chatbot/Api.js
new file mode 100644
index 0000000..983591c
--- /dev/null
+++ b/src/components/Chatbot/Api.js
@@ -0,0 +1,51 @@
+//src/components/Chatbot/Api.js
+import axios from 'axios';
+
+const PROCESS_URL = process.env.REACT_APP_PROCESS_URL || 'http://74.235.95.232:8004';
+const TRANSCRIPT_API_URL = 'http://74.235.95.232:5002/process_transcripts';
+
+export const sendToLLM = async (wordTimingJson, promptTemplate, userInput, task) => {
+  try {
+    const response = await axios.post(`${PROCESS_URL}/process_request`, {
+      text: wordTimingJson,
+      prompt_template: promptTemplate,
+      user_input: userInput,
+      task: task,
+    });
+    if (response.data && response.data.result) {
+      return response.data.result;
+    } else {
+      throw new Error('Invalid response format');
+    }
+  } catch (error) {
+    console.error('Error processing video content:', error);
+    if (error.response) {
+      console.error('Server responded with error:', error.response.data);
+      throw new Error(error.response.data.error || 'Server error');
+    } else if (error.request) {
+      console.error('No response received from server');
+      throw new Error('No response from server');
+    } else {
+      console.error('Error setting up request:', error.message);
+      throw error;
+    }
+  }
+};
+
+export const processTranscripts = async (editedTranscript) => {
+  try {
+    console.log('Sending request to process transcripts:');
+    console.log('Edited transcript:', editedTranscript);
+    const response = await axios.post(TRANSCRIPT_API_URL, {
+      edited_transcript: editedTranscript
+    });
+    console.log('Received response from server:', response.data);
+    return response.data;
+  } catch (error) {
+    console.error('Error processing transcripts:', error);
+    if (error.response) {
+      console.error('Server response:', error.response.data);
+    }
+    throw error;
+  }
+};
\ No newline at end of file
diff --git a/src/components/Chatbot/ChatBot.js b/src/components/Chatbot/ChatBot.js
new file mode 100644
index 0000000..eb307cd
--- /dev/null
+++ b/src/components/Chatbot/ChatBot.js
@@ -0,0 +1,354 @@
+import React, { useState } from 'react';
+import { Box, TextField, Button, Select, MenuItem, FormControl, CircularProgress } from '@mui/material';
+import { promptTemplates } from './promptTemplates';
+import { sendToLLM } from './Api';
+
+const ChatBot = ({ 
+  onSendMessage, 
+  messages, 
+  selectedBinClip, 
+  transcriptData,
+  onAddToTimeline,
+  timelineState,  // Make sure timelineState is being passed from App.js
+  timelineRows = [{ rowId: 0, clips: [], lastEnd: 0 }],  // Add default value
+  setTimelineRows 
+}) => {
+  const [input, setInput] = useState('');
+  const [selectedTemplate, setSelectedTemplate] = useState('');
+  const [isLoading, setIsLoading] = useState(false);
+
+  const processAndAddToTimeline = async (text) => {
+    try {
+      if (!selectedBinClip) {
+        throw new Error('No video clip selected');
+      }
+      console.log('Current timeline state:', {
+        totalDuration: timelineState.totalDuration,
+        existingClips: timelineState.clips.length,
+        timelineRows: timelineRows
+      });
+
+      // Parse words maintaining original order
+      const words = text.split(' ')
+        .filter(w => w.includes('|'))
+        .map(word => {
+          const [text, start, end, speaker] = word.split('|');
+          if (!start || !end || isNaN(parseFloat(start)) || isNaN(parseFloat(end))) {
+            throw new Error('Invalid word timing format');
+          }
+          return {
+            text,
+            start: parseFloat(start),
+            end: parseFloat(end),
+            speaker
+          };
+        });
+  
+      if (words.length === 0) {
+        throw new Error('No valid words found in response');
+      }
+  
+        // Group into segments by speaker
+        let segments = [];
+        let currentSegment = [words[0]];
+        let currentSpeaker = words[0].speaker;
+    
+        for (let i = 1; i < words.length; i++) {
+          const currentWord = words[i];
+          
+          if (currentWord.speaker !== currentSpeaker) {
+            segments.push(currentSegment);
+            currentSegment = [currentWord];
+            currentSpeaker = currentWord.speaker;
+          } else {
+            currentSegment.push(currentWord);
+          }
+        }
+        
+        if (currentSegment.length > 0) {
+          segments.push(currentSegment);
+        }
+    
+       const video = document.createElement('video');
+      video.src = URL.createObjectURL(selectedBinClip.file);
+  
+      video.addEventListener('loadedmetadata', () => {
+        // Keep track of where we are in the timeline
+        let timelinePosition = 0;
+
+        // Process each segment
+        segments.forEach((segment, index) => {
+          const segmentStart = Math.min(...segment.map(w => w.start));
+          const segmentEnd = Math.max(...segment.map(w => w.end));
+          const timelineDuration = segmentEnd - segmentStart;
+
+          // Simple math: start at current position, end = start + duration
+          const timelineStart = timelinePosition;
+          const timelineEnd = timelineStart + timelineDuration;
+
+          const clipData = {
+            id: `clip-${Date.now()}-${index}`,
+            file: selectedBinClip.file,
+            name: selectedBinClip.file.name,
+            startTime: segmentStart,
+            endTime: segmentEnd,
+            duration: timelineDuration,
+            source: {
+              startTime: 0,
+              endTime: video.duration,
+              duration: video.duration
+            },
+            transcript: segment.map(word => word.text).join(' '),
+            metadata: {
+              timeline: {
+                start: timelineStart,
+                end: timelineEnd,
+                duration: timelineDuration,
+                track: 0  // Always use track 0
+              },
+              playback: {
+                start: segmentStart,
+                end: segmentEnd,
+                duration: timelineDuration
+              }
+            },
+            selectionInfo: {
+              words: segment,
+              timeRange: {
+                start: segmentStart,
+                end: segmentEnd
+              },
+              text: segment.map(word => word.text).join(' '),
+              speaker: segment[0].speaker
+            }
+          };
+
+          console.log(`Adding clip ${index + 1}:`, {
+            text: clipData.transcript,
+            speaker: segment[0].speaker,
+            timelineStart,
+            timelineEnd,
+            duration: timelineDuration,
+            sourceStart: segmentStart,
+            sourceEnd: segmentEnd
+          });
+
+          // Update timeline rows for monitoring
+          setTimelineRows(prev => {
+            const updated = [...prev];
+            const targetRow = updated[0]; // Always use row 0
+            targetRow.clips.push(clipData);
+            targetRow.lastEnd = Math.max(targetRow.lastEnd, timelineEnd);
+            return updated;
+          });
+
+          // Move position to end of this clip for next iteration
+          timelinePosition = timelineEnd;
+
+          onAddToTimeline?.(clipData);
+        });
+  
+        video.src = '';
+        URL.revokeObjectURL(video.src);
+      });
+  
+      onSendMessage({
+        text: `Successfully added ${segments.length} clip${segments.length > 1 ? 's' : ''} to timeline`,
+        sender: 'bot',
+        isSuccess: true
+      });
+  
+    } catch (error) {
+      console.error('Error processing segments:', error);
+      onSendMessage({
+        text: `Error: ${error.message}. Please try again with a different prompt.`,
+        sender: 'bot',
+        isError: true
+      });
+    }
+  };
+
+  const handleSubmit = async (e) => {
+    e.preventDefault();
+    if (input.trim() && selectedTemplate) {
+      setIsLoading(true);
+      try {
+        onSendMessage({
+          text: input,
+          sender: 'user',
+          template: selectedTemplate
+        });
+
+        const templateContent = promptTemplates.find(t => t.name === selectedTemplate)?.template;
+        if (!templateContent) {
+          throw new Error('Template not found');
+        }
+
+        const wordTimingJson = transcriptData ? JSON.stringify(transcriptData) : '';
+        
+        const llmResponse = await sendToLLM(
+          wordTimingJson,
+          templateContent,
+          input,
+          'chat'
+        );
+        console.log(llmResponse)
+
+        // Process response and add to timeline
+        await processAndAddToTimeline(llmResponse);
+
+        setInput('');
+      } catch (error) {
+        console.error('Chat error:', error);
+        onSendMessage({
+          text: `Error: ${error.message}. Please try a different prompt.`,
+          sender: 'bot',
+          isError: true
+        });
+      } finally {
+        setIsLoading(false);
+      }
+    }
+  };
+
+  return (
+    <Box sx={{
+      position: 'fixed',
+      bottom: 0,
+      left: 0,
+      width: '240px',
+      height: '300px',
+      borderTop: 1,
+      borderRight: 1,
+      borderColor: 'divider',
+      backgroundColor: 'background.paper',
+      display: 'flex',
+      flexDirection: 'column',
+      zIndex: 1000,
+    }}>
+      {/* Header */}
+      <Box sx={{ 
+        p: 1, 
+        borderBottom: 1, 
+        borderColor: 'divider',
+        backgroundColor: 'background.default',
+        display: 'flex',
+        justifyContent: 'space-between',
+        alignItems: 'center'
+      }}>
+        <Box sx={{ fontSize: '16px', fontWeight: 'bold' }}>
+          Chatbot
+        </Box>
+        {isLoading && <CircularProgress size={20} />}
+      </Box>
+
+      {/* Messages Area */}
+      <Box 
+        sx={{ 
+          flex: 1,
+          overflow: 'auto',
+          p: 1,
+          backgroundColor: '#1e1e1e'
+        }}
+      >
+        {messages.map((msg, index) => (
+          <Box
+            key={index}
+            sx={{
+              p: 1,
+              mb: 1,
+              borderRadius: 1,
+              maxWidth: '85%',
+              wordBreak: 'break-word',
+              ...(msg.sender === 'user' ? {
+                ml: 'auto',
+                backgroundColor: '#0ea5e9',
+                color: 'white',
+              } : {
+                mr: 'auto',
+                backgroundColor: msg.isError ? '#ef4444' : 
+                               msg.isSuccess ? '#22c55e' : '#2d2d2d',
+                color: 'white',
+              })
+            }}
+          >
+            {msg.text}
+          </Box>
+        ))}
+      </Box>
+
+      {/* Input Area */}
+      <Box 
+        component="form" 
+        onSubmit={handleSubmit}
+        sx={{
+          p: 1,
+          display: 'flex',
+          flexDirection: 'column',
+          gap: 1,
+          borderTop: 1,
+          borderColor: 'divider',
+          backgroundColor: 'background.paper'
+        }}
+      >
+        <FormControl size="small" fullWidth>
+          <Select
+            value={selectedTemplate}
+            onChange={(e) => setSelectedTemplate(e.target.value)}
+            displayEmpty
+            disabled={isLoading}
+            sx={{
+              backgroundColor: '#2d2d2d',
+              '& .MuiOutlinedInput-notchedOutline': {
+                borderColor: '#404040',
+              },
+              '&:hover .MuiOutlinedInput-notchedOutline': {
+                borderColor: '#505050',
+              },
+            }}
+          >
+            <MenuItem value="">Select a template</MenuItem>
+            {promptTemplates.map(template => (
+              <MenuItem key={template.name} value={template.name}>
+                {template.name}
+              </MenuItem>
+            ))}
+          </Select>
+        </FormControl>
+        
+        <Box sx={{ display: 'flex', gap: 1 }}>
+          <TextField
+            size="small"
+            value={input}
+            onChange={(e) => setInput(e.target.value)}
+            placeholder="Type your message..."
+            disabled={isLoading}
+            fullWidth
+            sx={{
+              '& .MuiOutlinedInput-root': {
+                backgroundColor: '#2d2d2d',
+                '& fieldset': {
+                  borderColor: '#404040',
+                },
+                '&:hover fieldset': {
+                  borderColor: '#505050',
+                },
+              },
+            }}
+          />
+          <Button 
+            type="submit"
+            variant="contained" 
+            color="primary"
+            disabled={!input.trim() || !selectedTemplate || isLoading}
+            sx={{ minWidth: '60px' }}
+          >
+            Send
+          </Button>
+        </Box>
+      </Box>
+    </Box>
+  );
+};
+
+export default ChatBot;
\ No newline at end of file
diff --git a/src/components/Chatbot/ChatBot.module.css b/src/components/Chatbot/ChatBot.module.css
new file mode 100644
index 0000000..651ab76
--- /dev/null
+++ b/src/components/Chatbot/ChatBot.module.css
@@ -0,0 +1,97 @@
+.chatbot {
+  display: flex;
+  flex-direction: column;
+  height: 100%;
+  background-color: #f0f0f0;
+  border-radius: 8px;
+  overflow: hidden;
+}
+
+.chat-messages {
+  flex-grow: 1;
+  overflow-y: auto;
+  padding: 16px;
+  display: flex;
+  flex-direction: column;
+}
+
+.message {
+  max-width: 70%;
+  margin-bottom: 12px;
+  padding: 8px 12px;
+  border-radius: 18px;
+  font-size: 14px;
+  line-height: 1.4;
+}
+
+.message.user {
+  align-self: flex-end;
+  background-color: #007bff;
+  color: white;
+}
+
+.message.bot {
+  align-self: flex-start;
+  background-color: #e9e9eb;
+  color: black;
+}
+
+.chat-input-form {
+  display: flex;
+  padding: 16px;
+  background-color: white;
+}
+
+.chat-input {
+  flex-grow: 1;
+  padding: 8px 12px;
+  border: 1px solid #ccc;
+  border-radius: 20px;
+  font-size: 14px;
+}
+
+.chat-submit-button {
+  margin-left: 8px;
+  padding: 8px 16px;
+  background-color: #007bff;
+  color: white;
+  border: none;
+  border-radius: 20px;
+  font-size: 14px;
+  cursor: pointer;
+}
+
+.chat-submit-button:disabled {
+  background-color: #ccc;
+  cursor: not-allowed;
+}
+
+.chatbot-editor {
+  margin-top: 16px;
+  padding: 16px;
+  background-color: white;
+  border-radius: 8px;
+}
+
+.editable-response {
+  min-height: 100px;
+  max-height: 300px;
+  overflow-y: auto;
+  border: 1px solid #ccc;
+  padding: 10px;
+  white-space: pre-wrap;
+  background-color: #f9f9f9;
+  border-radius: 4px;
+}
+
+.debug-info {
+  margin-top: 16px;
+  padding: 16px;
+  background-color: #f0f0f0;
+  border-radius: 8px;
+}
+
+.debug-info pre {
+  white-space: pre-wrap;
+  word-break: break-all;
+}
\ No newline at end of file
diff --git a/src/components/Chatbot/ChatbotResponseViewer.js b/src/components/Chatbot/ChatbotResponseViewer.js
new file mode 100644
index 0000000..1142a92
--- /dev/null
+++ b/src/components/Chatbot/ChatbotResponseViewer.js
@@ -0,0 +1,35 @@
+import React from 'react';
+
+const ChatbotResponseViewer = ({ response }) => {
+  const handleCopy = (e) => {
+    e.preventDefault();
+    const selection = window.getSelection();
+    const selectedText = selection.toString();
+    
+    if (selectedText) {
+      e.clipboardData.setData('text/plain', selectedText);
+      console.log('Copied text:', selectedText);
+    }
+  };
+
+  return (
+    <div className="chatbot-response-viewer">
+      <h3>Chatbot Response</h3>
+      <div
+        onCopy={handleCopy}
+        style={{
+          minHeight: '100px',
+          maxHeight: '300px',
+          overflowY: 'auto',
+          border: '1px solid #ccc',
+          padding: '10px',
+          whiteSpace: 'pre-wrap'
+        }}
+      >
+        {response}
+      </div>
+    </div>
+  );
+};
+
+export default ChatbotResponseViewer;
\ No newline at end of file
diff --git a/src/components/Chatbot/promptTemplates.js b/src/components/Chatbot/promptTemplates.js
new file mode 100644
index 0000000..a99b9ad
--- /dev/null
+++ b/src/components/Chatbot/promptTemplates.js
@@ -0,0 +1,13 @@
+export const promptTemplates = [
+  {
+    name: "Edit Transcript",
+    template: `
+You are a video editor. Edit the provided transcript according to this request: {user_input}
+Focus on maintaining word-level timing and speaker information.
+Original Transcript JSON: {input_json}
+Respond with a string where each word is "word|start|end|speaker", separated by spaces.
+Ensure the edited transcript follows the user's instructions, maintains chronological order, and preserves timing and speaker info.
+Remove excluded words/segments. Adjust positions if order changes.
+    `
+  }
+];
diff --git a/src/components/Controls/ExportControls.js b/src/components/Controls/ExportControls.js
index eaeaa5d..3694817 100644
--- a/src/components/Controls/ExportControls.js
+++ b/src/components/Controls/ExportControls.js
@@ -19,6 +19,22 @@ const ExportControls = ({
   onDownloadState,
   onDebugClips
 }) => {
+  // Create wrapper functions to log before executing the passed functions
+  const handleExport = () => {
+    console.log("Export process started...");
+    onExport();
+  };
+
+  const handleDownloadState = () => {
+    console.log("Downloading current state...");
+    onDownloadState();
+  };
+
+  const handleDebugClips = () => {
+    console.log("Loading debug clips...");
+    onDebugClips();
+  };
+
   return (
     <Stack 
       direction="row" 
@@ -35,7 +51,7 @@ const ExportControls = ({
       <Button 
         variant="contained"
         startIcon={<FileDownload />}
-        onClick={onExport}
+        onClick={handleExport}  // Use the new logging function
         sx={{
           bgcolor: '#0ea5e9',
           color: 'white',
@@ -56,7 +72,7 @@ const ExportControls = ({
       <Box sx={{ display: 'flex', gap: 1 }}>
         <Tooltip title="Download Current State">
           <IconButton 
-            onClick={onDownloadState}
+            onClick={handleDownloadState}  // Use the new logging function
             size="small"
             sx={{ 
               bgcolor: 'rgba(255,255,255,0.1)',
@@ -68,7 +84,7 @@ const ExportControls = ({
         </Tooltip>
         <Tooltip title="Load Debug Clips">
           <IconButton 
-            onClick={onDebugClips}
+            onClick={handleDebugClips}  // Use the new logging function
             size="small"
             sx={{ 
               bgcolor: 'rgba(255,255,255,0.1)',
@@ -83,4 +99,4 @@ const ExportControls = ({
   );
 };
 
-export default ExportControls;
\ No newline at end of file
+export default ExportControls;
diff --git a/src/components/Layout/ChatbotLayout.js b/src/components/Layout/ChatbotLayout.js
new file mode 100644
index 0000000..afed165
--- /dev/null
+++ b/src/components/Layout/ChatbotLayout.js
@@ -0,0 +1,76 @@
+import React from 'react';
+import { Box, TextField, Button } from '@mui/material';
+
+const ChatbotLayout = () => {
+  return (
+    <Box sx={{
+      position: 'fixed',
+      bottom: 0,
+      left: 0,
+      width: '240px', // Match sidebar width
+      height: '300px',
+      borderTop: 1,
+      borderRight: 1,
+      borderColor: 'divider',
+      backgroundColor: 'background.paper',
+      display: 'flex',
+      flexDirection: 'column',
+      zIndex: 1000,
+    }}>
+      <Box sx={{ 
+        p: 1, 
+        borderBottom: 1, 
+        borderColor: 'divider',
+        backgroundColor: 'background.default'
+      }}>
+        <Box sx={{ fontSize: '16px', fontWeight: 'bold' }}>
+          Chatbot
+        </Box>
+      </Box>
+
+      <Box sx={{ 
+        flex: 1,
+        overflow: 'auto',
+        p: 1,
+        backgroundColor: '#1e1e1e'
+      }}>
+        {/* Chat messages would go here */}
+      </Box>
+
+      <Box sx={{
+        p: 1,
+        display: 'flex',
+        gap: 1,
+        borderTop: 1,
+        borderColor: 'divider',
+      }}>
+        <TextField
+          size="small"
+          placeholder="Type your message..."
+          variant="outlined"
+          fullWidth
+          sx={{
+            '& .MuiOutlinedInput-root': {
+              backgroundColor: '#2d2d2d',
+              '& fieldset': {
+                borderColor: '#404040',
+              },
+              '&:hover fieldset': {
+                borderColor: '#505050',
+              },
+            },
+          }}
+        />
+        <Button 
+          variant="contained" 
+          color="primary"
+          sx={{ minWidth: '60px' }}
+        >
+          Send
+        </Button>
+      </Box>
+    </Box>
+  );
+};
+
+export default ChatbotLayout;
\ No newline at end of file
diff --git a/src/components/Layout/MainLayout.js b/src/components/Layout/MainLayout.js
index de83e81..57e4137 100644
--- a/src/components/Layout/MainLayout.js
+++ b/src/components/Layout/MainLayout.js
@@ -1,14 +1,13 @@
-// src/components/Layout/MainLayout.js
 import React from 'react';
 import { Box } from '@mui/material';
-import MediaSidebar from '../MediaSidebar';
-
+import MediaSidebar from '../Media/MediaSidebar';
 
 const MainLayout = ({ 
   mediaFiles, 
   selectedBinClip,
   onFileUpload, 
   onFileSelect,
+  timelineProjects, // Make sure this prop is being passed
   children 
 }) => {
   return (
@@ -18,9 +17,16 @@ const MainLayout = ({
         onFileUpload={onFileUpload}
         onFileSelect={onFileSelect}
         selectedFile={selectedBinClip}
+        timelineProjects={{
+          selected: timelineProjects?.selected,
+          onSave: timelineProjects?.onSave,
+          onLoad: timelineProjects?.onLoad,
+          onDelete: timelineProjects?.onDelete
+        }}
       />
       {children}
     </Box>
   );
 };
+
 export default MainLayout;
\ No newline at end of file
diff --git a/src/components/Layout/SidebarLayout.js b/src/components/Layout/SidebarLayout.js
new file mode 100644
index 0000000..6d1eeac
--- /dev/null
+++ b/src/components/Layout/SidebarLayout.js
@@ -0,0 +1 @@
+//src/components/Layout/SidebarLayout.js 
\ No newline at end of file
diff --git a/src/components/Media/MediaBin.js b/src/components/Media/MediaBin.js
new file mode 100644
index 0000000..75046a1
--- /dev/null
+++ b/src/components/Media/MediaBin.js
@@ -0,0 +1,173 @@
+// src/components/Media/MediaBin.js
+import React, { useState } from 'react';
+import { 
+  Box, 
+  List, 
+  ListItem, 
+  ListItemText,
+  ListItemSecondaryAction,
+  IconButton,
+  Typography,
+  Tooltip,
+  Menu,
+  MenuItem,
+  Divider
+} from '@mui/material';
+import { 
+  MoreVertical, 
+  Trash2, 
+  VideoIcon, 
+  Clock,
+  Info 
+} from 'lucide-react';
+
+const MediaBin = ({ 
+  mediaFiles = [], 
+  onDeleteMedia,
+  onSelectMedia,
+  selectedMedia,
+  onAddToTimeline
+}) => {
+  const [contextMenu, setContextMenu] = useState(null);
+  const [selectedFile, setSelectedFile] = useState(null);
+
+  // Format file size
+  const formatSize = (bytes) => {
+    if (bytes === 0) return '0 Bytes';
+    const k = 1024;
+    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
+    const i = Math.floor(Math.log(bytes) / Math.log(k));
+    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
+  };
+
+  // Format duration
+  const formatDuration = (seconds) => {
+    const hrs = Math.floor(seconds / 3600);
+    const mins = Math.floor((seconds % 3600) / 60);
+    const secs = Math.floor(seconds % 60);
+    return `${hrs ? hrs + ':' : ''}${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
+  };
+
+  // Handle context menu
+  const handleContextMenu = (event, file) => {
+    event.preventDefault();
+    setSelectedFile(file);
+    setContextMenu({
+      mouseX: event.clientX - 2,
+      mouseY: event.clientY - 4,
+    });
+  };
+
+  // Close context menu
+  const handleCloseMenu = () => {
+    setContextMenu(null);
+  };
+
+  // Handle file selection
+  const handleSelect = (file) => {
+    onSelectMedia?.(file);
+  };
+
+  // Handle file deletion
+  const handleDelete = (file) => {
+    handleCloseMenu();
+    onDeleteMedia?.(file);
+  };
+
+  // Add to timeline
+  const handleAddToTimeline = (file) => {
+    handleCloseMenu();
+    onAddToTimeline?.(file);
+  };
+
+  return (
+    <Box sx={{ width: '100%', height: '100%' }}>
+      <Typography variant="subtitle1" sx={{ p: 2, borderBottom: 1, borderColor: 'divider' }}>
+        Media Bin
+      </Typography>
+
+      <List sx={{ 
+        width: '100%', 
+        bgcolor: 'background.paper',
+        overflow: 'auto',
+        maxHeight: 'calc(100vh - 200px)'
+      }}>
+        {mediaFiles.map((file) => (
+          <ListItem
+            key={file.name}
+            selected={selectedMedia?.name === file.name}
+            onClick={() => handleSelect(file)}
+            onContextMenu={(e) => handleContextMenu(e, file)}
+            sx={{ 
+              cursor: 'pointer',
+              '&:hover': {
+                bgcolor: 'action.hover'
+              }
+            }}
+          >
+            <VideoIcon size={20} style={{ marginRight: 8 }} />
+            <ListItemText
+              primary={file.name}
+              secondary={
+                <Box component="span" sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
+                  <Clock size={14} />
+                  {formatDuration(file.duration || 0)}
+                  <Divider orientation="vertical" flexItem />
+                  {formatSize(file.size)}
+                </Box>
+              }
+            />
+            <ListItemSecondaryAction>
+              <Tooltip title="More options">
+                <IconButton 
+                  edge="end" 
+                  onClick={(e) => handleContextMenu(e, file)}
+                >
+                  <MoreVertical size={20} />
+                </IconButton>
+              </Tooltip>
+            </ListItemSecondaryAction>
+          </ListItem>
+        ))}
+
+        {mediaFiles.length === 0 && (
+          <ListItem>
+            <ListItemText 
+              primary="No media files"
+              secondary="Upload videos to get started"
+              sx={{ textAlign: 'center', color: 'text.secondary' }}
+            />
+          </ListItem>
+        )}
+      </List>
+
+      {/* Context Menu */}
+      <Menu
+        open={contextMenu !== null}
+        onClose={handleCloseMenu}
+        anchorReference="anchorPosition"
+        anchorPosition={
+          contextMenu !== null
+            ? { top: contextMenu.mouseY, left: contextMenu.mouseX }
+            : undefined
+        }
+      >
+        <MenuItem onClick={() => handleAddToTimeline(selectedFile)}>
+          Add to Timeline
+        </MenuItem>
+        <MenuItem onClick={() => handleSelect(selectedFile)}>
+          View Details
+        </MenuItem>
+        <Divider />
+        <MenuItem 
+          onClick={() => handleDelete(selectedFile)}
+          sx={{ color: 'error.main' }}
+        >
+          Delete
+        </MenuItem>
+      </Menu>
+    </Box>
+  );
+};
+
+export default MediaBin;
\ No newline at end of file
diff --git a/src/components/Media/MediaSidebar.js b/src/components/Media/MediaSidebar.js
new file mode 100644
index 0000000..56e6a76
--- /dev/null
+++ b/src/components/Media/MediaSidebar.js
@@ -0,0 +1,394 @@
+import React, { useState } from 'react';
+import { 
+  Box, 
+  Typography, 
+  List, 
+  ListItem, 
+  ListItemIcon, 
+  ListItemText, 
+  LinearProgress, 
+  Button,
+  IconButton,
+  Tabs,
+  Tab,
+  Menu,
+  MenuItem,
+  Dialog,
+  DialogTitle,
+  DialogContent,
+  DialogActions,
+  TextField
+} from '@mui/material';
+import CloudUploadIcon from '@mui/icons-material/CloudUpload';
+import VideoFileIcon from '@mui/icons-material/VideoFile';
+import AudioFileIcon from '@mui/icons-material/AudioFile';
+import ImageIcon from '@mui/icons-material/Image';
+import InsertDriveFileIcon from '@mui/icons-material/InsertDriveFile';
+import TextSnippetIcon from '@mui/icons-material/TextSnippet'; // Add this import
+import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
+import TimelineIcon from '@mui/icons-material/Timeline';
+import DeleteIcon from '@mui/icons-material/Delete';
+import SaveIcon from '@mui/icons-material/Save';
+
+const MediaSidebar = ({ 
+  files, 
+  onFileUpload, 
+  onFileSelect, 
+  selectedFile,
+  timelineProjects 
+}) => {
+  const [uploading, setUploading] = useState(false);
+  const [uploadProgress, setUploadProgress] = useState({});
+  const [currentTab, setCurrentTab] = useState(0);
+  const [contextMenu, setContextMenu] = useState(null);
+
+  const [saveDialogOpen, setSaveDialogOpen] = useState(false);
+  const [newTimelineName, setNewTimelineName] = useState('');
+
+  const handleSaveClick = () => {
+    setSaveDialogOpen(true);
+    setNewTimelineName(`Timeline ${new Date().toLocaleString()}`);
+  };
+
+  const handleSaveConfirm = () => {
+    if (newTimelineName.trim()) {
+      timelineProjects?.onSave?.(newTimelineName.trim());
+      setSaveDialogOpen(false);
+    }
+  };
+
+  const handleFileUpload = (event) => {
+    const uploadedFiles = Array.from(event.target.files);
+    setUploading(true);
+    console.log(uploading)
+    uploadedFiles.forEach(file => {
+      const fileId = Date.now() + Math.random();
+      setUploadProgress(prev => ({
+        ...prev,
+        [fileId]: 0
+      }));
+
+      // Simulate progress
+      let progress = 0;
+      const interval = setInterval(() => {
+        progress += Math.random() * 20;
+        if (progress > 100) {
+          progress = 100;
+          clearInterval(interval);
+          
+          // Remove this file's progress after completion
+          setUploadProgress(prev => {
+            const newProgress = { ...prev };
+            delete newProgress[fileId];
+            return newProgress;
+          });
+          
+          if (onFileUpload) {
+            onFileUpload(file);
+          }
+        } else {
+          setUploadProgress(prev => ({
+            ...prev,
+            [fileId]: progress
+          }));
+        }
+      }, 500);
+    });
+
+    // Reset uploading state when all files are done
+    const checkUploadComplete = setInterval(() => {
+      setUploadProgress(prev => {
+        if (Object.keys(prev).length === 0) {
+          setUploading(false);
+          clearInterval(checkUploadComplete);
+        }
+        return prev;
+      });
+    }, 1000);
+  };
+
+  const getFileIcon = (type) => {
+    if (type.startsWith('video/')) return <VideoFileIcon />;
+    if (type.startsWith('image/')) return <ImageIcon />;
+    if (type.startsWith('audio/')) return <AudioFileIcon />;
+    // Add handling for JSON/transcript files
+    if (type === 'application/json' || type.endsWith('.json')) return <TextSnippetIcon />;
+    return <InsertDriveFileIcon />;
+  };
+
+  const formatFileSize = (bytes) => {
+    if (bytes === 0) return '0 Bytes';
+    const k = 1024;
+    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
+    const i = Math.floor(Math.log(bytes) / Math.log(k));
+    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
+  };
+
+  // Timeline handling
+  const handleTimelineContextMenu = (event, timeline) => {
+    event.preventDefault();
+    setContextMenu({
+      mouseX: event.clientX - 2,
+      mouseY: event.clientY - 4,
+      timeline
+    });
+  };
+
+  const handleContextClose = () => {
+    setContextMenu(null);
+  };
+
+  const handleDeleteTimeline = () => {
+    if (contextMenu?.timeline) {
+      timelineProjects?.onDelete?.(contextMenu.timeline);
+      handleContextClose();
+    }
+  };
+
+  const handleLoadTimeline = () => {
+    if (contextMenu?.timeline) {
+      timelineProjects?.onLoad?.(contextMenu.timeline);
+      handleContextClose();
+    }
+  };
+
+  return (
+    <Box 
+      sx={{
+        width: 240,
+        height: '100%',
+        bgcolor: 'background.paper',
+        borderRight: 1,
+        borderColor: 'divider',
+        display: 'flex',
+        flexDirection: 'column'
+      }}
+    >
+      {/* Tab Navigation */}
+      <Tabs 
+        value={currentTab} 
+        onChange={(_, newValue) => setCurrentTab(newValue)}
+        sx={{ borderBottom: 1, borderColor: 'divider' }}
+      >
+        <Tab label="Media" />
+        <Tab label="Timelines" />
+      </Tabs>
+
+      {/* Media Tab */}
+      {currentTab === 0 && (
+        <>
+       <Box sx={{ p: 2, borderBottom: 1, borderColor: 'divider' }}>
+          <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 2 }}>
+            <Typography variant="h6">Media</Typography>
+            <IconButton size="small">
+              <ExpandMoreIcon />
+            </IconButton>
+          </Box>
+
+          <Typography variant="caption" display="block" sx={{ mb: 1, color: 'text.secondary' }}>
+            Upload video files with matching .json transcripts
+          </Typography>
+
+          <label htmlFor="upload-input">
+            <input
+              id="upload-input"
+              type="file"
+              multiple
+              onChange={handleFileUpload}
+              style={{ display: 'none' }}
+              accept="video/*,image/*,audio/*,.json" // Added .json
+            />
+            <Button
+              component="span"
+              variant="outlined"
+              startIcon={<CloudUploadIcon />}
+              fullWidth
+              sx={{ 
+                color: 'primary.main',
+                borderColor: 'primary.main',
+                '&:hover': {
+                  borderColor: 'primary.dark',
+                  bgcolor: 'action.hover'
+                }
+              }}
+            >
+              Upload
+            </Button>
+            </label>
+          </Box>
+
+          <List sx={{ flexGrow: 1, overflow: 'auto' }}>
+            {files?.map(file => (
+              <ListItem 
+                key={file.id}
+                selected={selectedFile?.id === file.id}
+                onClick={() => onFileSelect?.(file)}
+                sx={{
+                  borderBottom: 1,
+                  borderColor: 'divider',
+                  '&:hover': {
+                    bgcolor: 'action.hover'
+                  },
+                  cursor: 'pointer'
+                }}
+              >
+                <ListItemIcon sx={{ minWidth: 40 }}>
+                  {getFileIcon(file.type)}
+                </ListItemIcon>
+                <ListItemText 
+                  primary={file.name}
+                  secondary={formatFileSize(file.size)}
+                  primaryTypographyProps={{
+                    variant: 'body2',
+                    noWrap: true
+                  }}
+                  secondaryTypographyProps={{
+                    variant: 'caption'
+                  }}
+                />
+              </ListItem>
+            ))}
+
+            {Object.entries(uploadProgress).map(([id, progress]) => (
+              progress < 100 && (
+                <ListItem 
+                  key={id}
+                  sx={{
+                    borderBottom: 1,
+                    borderColor: 'divider',
+                    display: 'block'
+                  }}
+                >
+                  <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
+                    <CloudUploadIcon sx={{ mr: 1, fontSize: 20, color: 'primary.main' }} />
+                    <Typography variant="body2">Uploading...</Typography>
+                  </Box>
+                  <LinearProgress 
+                    variant="determinate" 
+                    value={progress}
+                    sx={{ height: 2 }}
+                  />
+                </ListItem>
+              )
+            ))}
+          </List>
+        </>
+      )}
+
+      {/* Timelines Tab */}
+      {currentTab === 1 && (
+      <>
+        <Box sx={{ p: 2, borderBottom: 1, borderColor: 'divider' }}>
+          <Button
+            variant="outlined"
+            startIcon={<SaveIcon />}
+            fullWidth
+            onClick={handleSaveClick}
+            sx={{ 
+              color: 'primary.main',
+              borderColor: 'primary.main',
+              '&:hover': {
+                borderColor: 'primary.dark',
+                bgcolor: 'action.hover'
+              }
+            }}
+          >
+            Save Timeline
+          </Button>
+        </Box>
+
+        {/* Save Dialog */}
+        <Dialog 
+          open={saveDialogOpen} 
+          onClose={() => setSaveDialogOpen(false)}
+          maxWidth="sm"
+          fullWidth
+        >
+          <DialogTitle>Save Timeline</DialogTitle>
+          <DialogContent>
+            <TextField
+              autoFocus
+              margin="dense"
+              label="Timeline Name"
+              fullWidth
+              value={newTimelineName}
+              onChange={(e) => setNewTimelineName(e.target.value)}
+              variant="outlined"
+              sx={{ mt: 1 }}
+            />
+          </DialogContent>
+          <DialogActions>
+            <Button onClick={() => setSaveDialogOpen(false)}>
+              Cancel
+            </Button>
+            <Button onClick={handleSaveConfirm} variant="contained">
+              Save
+            </Button>
+          </DialogActions>
+        </Dialog>
+        
+          <List sx={{ flexGrow: 1, overflow: 'auto' }}>
+            {Object.entries(JSON.parse(localStorage.getItem('timelineProjects') || '{}')).map(([name, timeline]) => (
+              <ListItem
+                key={name}
+                selected={timelineProjects?.selected === name}
+                onContextMenu={(e) => handleTimelineContextMenu(e, name)}
+                onClick={() => timelineProjects?.onLoad?.(name)}
+                sx={{
+                  borderBottom: 1,
+                  borderColor: 'divider',
+                  cursor: 'pointer',
+                  '&:hover': {
+                    bgcolor: 'action.hover'
+                  }
+                }}
+              >
+                <ListItemIcon sx={{ minWidth: 40 }}>
+                  <TimelineIcon />
+                </ListItemIcon>
+                <ListItemText 
+                  primary={name}
+                  secondary={new Date(timeline.timestamp).toLocaleString()}
+                  primaryTypographyProps={{
+                    variant: 'body2',
+                    noWrap: true
+                  }}
+                  secondaryTypographyProps={{
+                    variant: 'caption'
+                  }}
+                />
+              </ListItem>
+            ))}
+          </List>
+
+          {/* Context Menu */}
+          <Menu
+            open={contextMenu !== null}
+            onClose={handleContextClose}
+            anchorReference="anchorPosition"
+            anchorPosition={
+              contextMenu !== null
+                ? { top: contextMenu.mouseY, left: contextMenu.mouseX }
+                : undefined
+            }
+          >
+            <MenuItem onClick={handleLoadTimeline}>
+              <ListItemIcon>
+                <TimelineIcon fontSize="small" />
+              </ListItemIcon>
+              Load Timeline
+            </MenuItem>
+            <MenuItem onClick={handleDeleteTimeline}>
+              <ListItemIcon>
+                <DeleteIcon fontSize="small" color="error" />
+              </ListItemIcon>
+              <Typography color="error">Delete Timeline</Typography>
+            </MenuItem>
+          </Menu>
+        </>
+      )}
+    </Box>
+  );
+};
+
+export default MediaSidebar;
\ No newline at end of file
diff --git a/src/components/MediaSidebar.js b/src/components/MediaSidebar.js
deleted file mode 100644
index 57218e9..0000000
--- a/src/components/MediaSidebar.js
+++ /dev/null
@@ -1,177 +0,0 @@
-import React, { useState } from 'react';
-import Box from '@mui/material/Box';
-import Typography from '@mui/material/Typography';
-import IconButton from '@mui/material/IconButton';
-import List from '@mui/material/List';
-import ListItem from '@mui/material/ListItem';
-import ListItemIcon from '@mui/material/ListItemIcon';
-import ListItemText from '@mui/material/ListItemText';
-import LinearProgress from '@mui/material/LinearProgress';
-import Button from '@mui/material/Button';
-import CloudUploadIcon from '@mui/icons-material/CloudUpload';
-import VideoFileIcon from '@mui/icons-material/VideoFile';
-import AudioFileIcon from '@mui/icons-material/AudioFile';
-import ImageIcon from '@mui/icons-material/Image';
-import InsertDriveFileIcon from '@mui/icons-material/InsertDriveFile';
-import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
-
-const MediaSidebar = ({ files, onFileUpload, onFileSelect, selectedFile }) => {
-  // eslint-disable-next-line no-unused-vars
-  const [uploading, setUploading] = useState(false);
-  const [uploadProgress, setUploadProgress] = useState({});
-
-  const handleFileUpload = (event) => {
-    const uploadedFiles = Array.from(event.target.files);
-    setUploading(true);
-    
-    uploadedFiles.forEach(file => {
-      const fileId = Date.now() + Math.random();
-      setUploadProgress(prev => ({
-        ...prev,
-        [fileId]: 0
-      }));
-
-      // Simulate progress
-      let progress = 0;
-      const interval = setInterval(() => {
-        progress += Math.random() * 20;
-        if (progress > 100) {
-          progress = 100;
-          clearInterval(interval);
-          setUploading(false);
-          
-          if (onFileUpload) {
-            onFileUpload(file);
-          }
-        }
-        setUploadProgress(prev => ({
-          ...prev,
-          [fileId]: progress
-        }));
-      }, 500);
-    });
-  };
-
-  const getFileIcon = (type) => {
-    if (type.startsWith('video/')) return <VideoFileIcon />;
-    if (type.startsWith('image/')) return <ImageIcon />;
-    if (type.startsWith('audio/')) return <AudioFileIcon />;
-    return <InsertDriveFileIcon />;
-  };
-
-  const formatFileSize = (bytes) => {
-    if (bytes === 0) return '0 Bytes';
-    const k = 1024;
-    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
-    const i = Math.floor(Math.log(bytes) / Math.log(k));
-    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
-  };
-
-  return (
-    <Box 
-      sx={{
-        width: 240,
-        height: '100%',
-        bgcolor: 'background.paper',
-        borderRight: 1,
-        borderColor: 'divider',
-        display: 'flex',
-        flexDirection: 'column'
-      }}
-    >
-      <Box sx={{ p: 2, borderBottom: 1, borderColor: 'divider' }}>
-        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 2 }}>
-          <Typography variant="h6">Media</Typography>
-          <IconButton size="small">
-            <ExpandMoreIcon />
-          </IconButton>
-        </Box>
-        
-        <label htmlFor="upload-input">
-          <input
-            id="upload-input"
-            type="file"
-            multiple
-            onChange={handleFileUpload}
-            style={{ display: 'none' }}
-            accept="video/*,image/*,audio/*"
-          />
-          <Button
-            component="span"
-            variant="outlined"
-            startIcon={<CloudUploadIcon />}
-            fullWidth
-            sx={{ 
-              color: 'primary.main',
-              borderColor: 'primary.main',
-              '&:hover': {
-                borderColor: 'primary.dark',
-                bgcolor: 'action.hover'
-              }
-            }}
-          >
-            Upload
-          </Button>
-        </label>
-      </Box>
-
-      <List sx={{ flexGrow: 1, overflow: 'auto' }}>
-        {files?.map(file => (
-          <ListItem 
-            key={file.id}
-            selected={selectedFile?.id === file.id}
-            onClick={() => onFileSelect?.(file)}
-            sx={{
-              borderBottom: 1,
-              borderColor: 'divider',
-              '&:hover': {
-                bgcolor: 'action.hover'
-              },
-              cursor: 'pointer'
-            }}
-          >
-            <ListItemIcon sx={{ minWidth: 40 }}>
-              {getFileIcon(file.type)}
-            </ListItemIcon>
-            <ListItemText 
-              primary={file.name}
-              secondary={formatFileSize(file.size)}
-              primaryTypographyProps={{
-                variant: 'body2',
-                noWrap: true
-              }}
-              secondaryTypographyProps={{
-                variant: 'caption'
-              }}
-            />
-          </ListItem>
-        ))}
-
-        {Object.entries(uploadProgress).map(([id, progress]) => (
-          progress < 100 && (
-            <ListItem 
-              key={id}
-              sx={{
-                borderBottom: 1,
-                borderColor: 'divider',
-                display: 'block'
-              }}
-            >
-              <Box sx={{ display: 'flex', alignItems: 'center', mb: 1 }}>
-                <CloudUploadIcon sx={{ mr: 1, fontSize: 20, color: 'primary.main' }} />
-                <Typography variant="body2">Uploading...</Typography>
-              </Box>
-              <LinearProgress 
-                variant="determinate" 
-                value={progress}
-                sx={{ height: 2 }}
-              />
-            </ListItem>
-          )
-        ))}
-      </List>
-    </Box>
-  );
-};
-
-export default MediaSidebar;
\ No newline at end of file
diff --git a/src/components/Timeline/TimelineClip.js b/src/components/Timeline/TimelineClip.js
index ff7059d..baf431a 100644
--- a/src/components/Timeline/TimelineClip.js
+++ b/src/components/Timeline/TimelineClip.js
@@ -1,9 +1,8 @@
-import React, { useEffect, useRef, useState, useCallback } from 'react';
+import React, { useEffect, useRef, useState, useCallback, useMemo } from 'react';
 import { Box, Skeleton, Tooltip, Typography } from '@mui/material';
 import { AlertCircle } from 'lucide-react';
 
-
-const thumbnailCache = new Map();
+const thumbnailCacheByClip = new Map();
 const THUMBNAIL_WIDTH = 80;
 
 const TimelineClip = ({ 
@@ -19,127 +18,164 @@ const TimelineClip = ({
   const videoRef = useRef(null);
   const videoUrlRef = useRef(null);
   const containerRef = useRef(null);
-  const isInitialized = useRef(false); // Moved to component level
+  const containerWidth = useRef(null);
+  const isInitialized = useRef(false);
+  const initialTimelineStart = useRef(null);
+  const lastThumbnailKey = useRef(null);
+ // Add this ref to store original values
+ const originalValues = useRef({
+  startTime: clip.startTime,
+  endTime: clip.endTime,
+  duration: clip.endTime - clip.startTime
+});
+
+const onUpdateData = useCallback((newData) => {
+  action.data = newData;
+}, [action]);
+
+const timingValues = useMemo(() => ({
+  startTime: clip.startTime,
+  endTime: clip.endTime,
+  actionStart: action.start,
+  actionEnd: action.end,
+  resizeDir: clip.resizeDir,
+  sourceStartTime: clip.source?.startTime || 0,
+  sourceEndTime: clip.source?.endTime,
+  clipId: clip.id,
+  metadata: clip.metadata,
+  hasMetadata: Boolean(clip.metadata?.timeline),
+  clipData: clip,
+  updateData: onUpdateData,
+}), [
+  clip,
+  action.start,
+  action.end,
+  onUpdateData,
+]);
 
-  // Calculate number of thumbnails based on container width
   const getThumbnailCount = useCallback(() => {
-    if (!containerRef.current) return 5;
-    const width = containerRef.current.offsetWidth;
-    return Math.max(3, Math.ceil(width / THUMBNAIL_WIDTH));
+    if (!containerWidth.current) return 5;
+    return Math.max(3, Math.ceil(containerWidth.current / THUMBNAIL_WIDTH));
   }, []);
 
-  // Format time helper
   const formatTime = (seconds) => {
     const mins = Math.floor(seconds / 60);
     const secs = Math.floor(seconds % 60);
     const ms = Math.floor((seconds % 1) * 100);
     return `${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
   };
-  const initialTimelineStart = useRef(null);
 
   const calculateCurrentTimes = useCallback(() => {
-    if (!isInitialized.current || !clip.metadata?.timeline) {
-        isInitialized.current = true;
-        initialTimelineStart.current = action.start;  // Store initial position
-        
-        action.data = {
-            ...clip,
-            metadata: {
-                timeline: {
-                    start: action.start,
-                    end: action.end,
-                    duration: action.end - action.start,
-                    initialStart: action.start  // Store this too
-                },
-                playback: {
-                    start: clip.startTime,
-                    end: clip.endTime,
-                    duration: clip.endTime - clip.startTime
-                }
-            }
-        };
-
-        return {
-            timelinePosition: formatTime(action.start),
-            originalStart: formatTime(clip.startTime),
-            originalEnd: formatTime(clip.endTime),
-            currentStart: formatTime(clip.startTime),
-            currentEnd: formatTime(clip.endTime),
-            duration: formatTime(clip.endTime - clip.startTime),
-            originalDuration: formatTime(clip.endTime - clip.startTime)
-        };
+    if (!isInitialized.current || !timingValues.hasMetadata) {
+      isInitialized.current = true;
+      initialTimelineStart.current = timingValues.actionStart;
+      
+      timingValues.updateData({
+        ...timingValues.clipData,
+        metadata: {
+          timeline: {
+            start: timingValues.actionStart,
+            end: timingValues.actionEnd,
+            duration: timingValues.actionEnd - timingValues.actionStart,
+            initialStart: timingValues.actionStart
+          },
+          playback: {
+            start: timingValues.startTime,
+            end: timingValues.endTime,
+            duration: timingValues.endTime - timingValues.startTime
+          }
+        }
+      });
+
+      return {
+        timelinePosition: formatTime(timingValues.actionStart),
+        originalStart: formatTime(originalValues.current.startTime),  // Use ref values
+        originalEnd: formatTime(originalValues.current.endTime),      // Use ref values
+        currentStart: formatTime(timingValues.startTime),
+        currentEnd: formatTime(timingValues.endTime),
+        duration: formatTime(timingValues.endTime - timingValues.startTime),
+        originalDuration: formatTime(originalValues.current.duration) // Use ref value
+      };
     }
 
-    // Calculate new times based on resize
-    let currentStart = clip.startTime;
-    let currentEnd = clip.endTime;
-
-    if (clip.resizeDir === 'left') {
-      currentEnd = clip.endTime;
-      const newDuration = action.end - action.start;
-      currentStart = clip.endTime - newDuration;
-    } else if (clip.resizeDir === 'right') {
-        currentStart = clip.startTime;
-        const newDuration = action.end - action.start;
-        currentEnd = clip.startTime + newDuration;
+    let currentStart = timingValues.startTime;
+    let currentEnd = timingValues.endTime;
+
+    if (timingValues.resizeDir === 'left') {
+      currentEnd = timingValues.endTime;
+      const newDuration = timingValues.actionEnd - timingValues.actionStart;
+      currentStart = timingValues.endTime - newDuration;
+    } else if (timingValues.resizeDir === 'right') {
+      currentStart = timingValues.startTime;
+      const newDuration = timingValues.actionEnd - timingValues.actionStart;
+      currentEnd = timingValues.startTime + newDuration;
     }
+    
+    currentEnd = Math.min(currentEnd, timingValues.sourceEndTime);
+    currentStart = Math.max(currentStart, timingValues.sourceStartTime);
 
-    // Update action.data with new times
-    action.data = {
-        ...clip,
-        startTime: currentStart,
-        endTime: currentEnd,
-        metadata: {
-            timeline: {
-                start: action.start,
-                end: action.end,
-                duration: action.end - action.start,
-                initialStart: clip.metadata.timeline.initialStart || initialTimelineStart.current  // Preserve initial start
-            },
-            playback: {
-                start: currentStart,
-                end: currentEnd,
-                duration: currentEnd - currentStart
-            }
+    timingValues.updateData({
+      ...timingValues.clipData,
+      startTime: currentStart,
+      endTime: currentEnd,
+      metadata: {
+        timeline: {
+          start: timingValues.actionStart,
+          end: timingValues.actionEnd,
+          duration: timingValues.actionEnd - timingValues.actionStart,
+          initialStart: timingValues.metadata?.timeline?.initialStart || initialTimelineStart.current
+        },
+        playback: {
+          start: currentStart,
+          end: currentEnd,
+          duration: currentEnd - currentStart
         }
+      }
+    });
+
+    return {
+      timelinePosition: formatTime(timingValues.actionStart),
+      originalStart: formatTime(originalValues.current.startTime),  // Use ref values
+      originalEnd: formatTime(originalValues.current.endTime),      // Use ref values
+      currentStart: formatTime(currentStart),
+      currentEnd: formatTime(currentEnd),
+      duration: formatTime(currentEnd - currentStart),
+      originalDuration: formatTime(originalValues.current.duration) // Use ref value
     };
+  }, [timingValues]); 
+
+  const thumbnailParams = useMemo(() => {
+    const timingInfo = calculateCurrentTimes();
+    if (!timingInfo) return null;
 
     return {
-        timelinePosition: formatTime(action.start),
-        originalStart: formatTime(clip.startTime),
-        originalEnd: formatTime(clip.endTime),
-        currentStart: formatTime(currentStart),
-        currentEnd: formatTime(currentEnd),
-        duration: formatTime(currentEnd - currentStart),
-        originalDuration: formatTime(clip.endTime - clip.startTime)
+      clipId: timingValues.clipId,
+      currentStart: parseFloat(timingInfo.currentStart.split(':').pop()),
+      currentEnd: parseFloat(timingInfo.currentEnd.split(':').pop()),
+      width: containerWidth.current
     };
-}, [clip, action]);
+  }, [calculateCurrentTimes, timingValues.clipId]);
 
   const generateThumbnails = useCallback(async () => {
-    if (!videoRef.current || !clip.file || !containerRef.current) return;
+    if (!videoRef.current || !clip.file || !thumbnailParams) return;
+    
+    const { clipId, currentStart, currentEnd, width } = thumbnailParams;
+    const cacheKey = `${clipId}-${currentStart}-${currentEnd}-${width}`;
+
+    // Skip if we're already showing these thumbnails
+    if (lastThumbnailKey.current === cacheKey) return;
     
+    if (thumbnailCacheByClip.has(cacheKey)) {
+      lastThumbnailKey.current = cacheKey;
+      setThumbnails(thumbnailCacheByClip.get(cacheKey));
+      setLoading(false);
+      return;
+    }
+
     setLoading(true);
     setError(null);
 
     try {
-      // Get clip state for accurate timing
-      const timingInfo = calculateCurrentTimes();
-      if (!timingInfo) return;
-
-      // Parse times removing formatting
-      const currentStart = parseFloat(timingInfo.currentStart.split(':').pop());
-      const currentEnd = parseFloat(timingInfo.currentEnd.split(':').pop());
-
-      
-      // Update cache key to include current timing
-      const cacheKey = `${clip.file.name}-${currentStart}-${currentEnd}-${containerRef.current.offsetWidth}`;
-      
-      if (thumbnailCache.has(cacheKey)) {
-        setThumbnails(thumbnailCache.get(cacheKey));
-        setLoading(false);
-        return;
-      }
-
       const video = videoRef.current;
       const newThumbnails = [];
       
@@ -158,14 +194,10 @@ const TimelineClip = ({
       const duration = currentEnd - currentStart;
       
       for (let i = 0; i < thumbnailCount; i++) {
-        // Calculate position within the current segment
         const progress = i / (thumbnailCount - 1);
         const timeOffset = progress * duration;
-        
-        // Map to source video time
         const sourceTime = currentStart + timeOffset;
         
-        // Set video to the source time position
         video.currentTime = sourceTime;
         
         await new Promise((resolve) => {
@@ -182,7 +214,8 @@ const TimelineClip = ({
         newThumbnails.push(canvas.toDataURL('image/jpeg', 0.7));
       }
       
-      thumbnailCache.set(cacheKey, newThumbnails);
+      lastThumbnailKey.current = cacheKey;
+      thumbnailCacheByClip.set(cacheKey, newThumbnails);
       setThumbnails(newThumbnails);
 
     } catch (err) {
@@ -191,9 +224,16 @@ const TimelineClip = ({
     } finally {
       setLoading(false);
     }
-  }, [clip.file, calculateCurrentTimes, getThumbnailCount]);
+  }, [clip.file, getThumbnailCount, thumbnailParams]);
 
-  // Handle video source and thumbnail generation
+  // Initialize container width
+  useEffect(() => {
+    if (containerRef.current) {
+      containerWidth.current = containerRef.current.offsetWidth;
+    }
+  }, []);
+
+  // Handle video source
   useEffect(() => {
     if (videoRef.current && clip.file) {
       if (videoUrlRef.current) {
@@ -212,36 +252,66 @@ const TimelineClip = ({
     };
   }, [clip.file, generateThumbnails]);
 
-  // Handle resize
+  // Handle resize with debouncing
   useEffect(() => {
+    let resizeTimeout;
+    
+    const handleResize = () => {
+      if (containerRef.current) {
+        const newWidth = containerRef.current.offsetWidth;
+        if (newWidth !== containerWidth.current) {
+          containerWidth.current = newWidth;
+          generateThumbnails();
+        }
+      }
+    };
+
     const observer = new ResizeObserver(() => {
-      generateThumbnails();
+      clearTimeout(resizeTimeout);
+      resizeTimeout = setTimeout(handleResize, 150);
     });
 
     if (containerRef.current) {
       observer.observe(containerRef.current);
     }
 
-    return () => observer.disconnect();
+    return () => {
+      clearTimeout(resizeTimeout);
+      observer.disconnect();
+    };
   }, [generateThumbnails]);
 
-  // Add effect to regenerate thumbnails on clip changes
+  // Generate thumbnails on essential changes
   useEffect(() => {
-    generateThumbnails();
-  }, [clip.startTime, clip.endTime, action.start, action.end, generateThumbnails]);
+    if (thumbnailParams) {
+      generateThumbnails();
+    }
+  }, [thumbnailParams, generateThumbnails]);
 
-  // Cache cleanup
+  // Clean up clip-specific cache
   useEffect(() => {
-    if (thumbnailCache.size > 50) {
-      const entriesToRemove = Array.from(thumbnailCache.keys()).slice(0, 20);
-      entriesToRemove.forEach(key => thumbnailCache.delete(key));
+    if (thumbnailCacheByClip.size > 50) {
+      const clipPrefix = `${timingValues.clipId}-`;
+      const entriesToRemove = Array.from(thumbnailCacheByClip.keys())
+        .filter(key => key.startsWith(clipPrefix))
+        .slice(0, 20);
+      entriesToRemove.forEach(key => thumbnailCacheByClip.delete(key));
     }
-  }, [thumbnails]);
+    
+    return () => {
+      const clipPrefix = `${timingValues.clipId}-`;
+      for (const key of thumbnailCacheByClip.keys()) {
+        if (key.startsWith(clipPrefix)) {
+          thumbnailCacheByClip.delete(key);
+        }
+      }
+    };
+  }, [timingValues.clipId]);
 
-  // Update hover info whenever the clip position or duration changes
+  // Update hover info
   useEffect(() => {
     setHoverInfo(calculateCurrentTimes());
-  }, [action.start, action.end, calculateCurrentTimes]);
+  }, [calculateCurrentTimes]);
 
   const tooltipContent = () => (
     <Box sx={{ p: 1 }}>
diff --git a/src/components/Timeline/TimelineControls.js b/src/components/Timeline/TimelineControls.js
index 99ac458..28b8575 100644
--- a/src/components/Timeline/TimelineControls.js
+++ b/src/components/Timeline/TimelineControls.js
@@ -16,13 +16,101 @@ import {
 
 const TimelineControls = ({
   onExport, 
-  onDownloadState, 
-  onDebugClips, 
+  timelineState,
+  selectedClipId,
   scale, 
   onZoomIn, 
   onZoomOut, 
-  onZoomReset
+  onZoomReset,
+  onDebugClips
 }) => {
+  const handleDownloadState = () => {
+    console.log("downloading file");
+    
+    try {
+      const stateToExport = {
+        version: "2.0",
+        timestamp: new Date().toISOString(),
+        timeline: {
+          clips: timelineState.clips.map(clip => {
+            // Get the stored metadata that was updated by TimelineClip
+            const metadata = clip.metadata || {};
+            const playback = metadata.playback || {};
+            const timeline = metadata.timeline || {};
+
+            return {
+              id: clip.id,
+              source: {
+                startTime: playback.start,  // Use stored playback times
+                endTime: playback.end,
+                duration: clip.source?.duration,
+                name: clip.file.name
+              },
+              file: {
+                name: clip.file.name,
+                size: clip.file.size,
+                type: clip.file.type
+              },
+              metadata: {
+                originalDuration: clip.source?.duration,
+                timeline: {
+                  sourceStart: clip.source?.startTime,
+                  sourceEnd: clip.source?.endTime,
+                  start: timeline.start,
+                  end: timeline.end,
+                  duration: timeline.duration
+                },
+                playback: {
+                  start: playback.start,
+                  end: playback.end,
+                  duration: playback.duration
+                }
+              },
+              position: {
+                timelineStart: timeline.start,
+                timelineEnd: timeline.end,
+                currentStart: playback.start,
+                currentEnd: playback.end,
+                track: timeline.track || 0
+              },
+              state: {
+                selected: clip.id === selectedClipId,
+                effectId: clip.effectId || 'default'
+              }
+            };
+          }),
+          duration: timelineState.duration || 0,
+          settings: {
+            scale: scale || 1,
+            effects: timelineState.settings?.effects || {}
+          }
+        }
+      };
+
+      // Create and download the file
+      const blob = new Blob([JSON.stringify(stateToExport, null, 2)], {
+        type: 'application/json'
+      });
+      
+      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
+      const filename = `timeline_export_${timestamp}.json`;
+      
+      const url = URL.createObjectURL(blob);
+      const link = document.createElement('a');
+      link.href = url;
+      link.download = filename;
+      document.body.appendChild(link);
+      link.click();
+      document.body.removeChild(link);
+      URL.revokeObjectURL(url);
+
+      console.log('Exported timeline state:', stateToExport);
+
+    } catch (error) {
+      console.error('Failed to download state:', error);
+    }
+  };
+
   return (
     <Stack direction="row" spacing={2} alignItems="center">
       <Button 
@@ -89,7 +177,7 @@ const TimelineControls = ({
       <Box sx={{ ml: 'auto', display: 'flex', gap: 1 }}>
         <Tooltip title="Download Current State">
           <IconButton 
-            onClick={onDownloadState}
+            onClick={handleDownloadState}
             size="small"
             sx={{ 
               bgcolor: 'rgba(255,255,255,0.1)',
diff --git a/src/components/Timeline/TimelineExport.js b/src/components/Timeline/TimelineExport.js
index 6ec048e..e0d303a 100644
--- a/src/components/Timeline/TimelineExport.js
+++ b/src/components/Timeline/TimelineExport.js
@@ -3,42 +3,25 @@ import { useCallback } from 'react';
 const useTimelineExport = (timelineState) => {
   const exportTimelineData = useCallback(() => {
     try {
-      // Enhanced debug logs
-      console.log('=== TIMELINE EXPORT START ===');
-      console.log('Timeline State:', {
-        clips: timelineState.clips,
-        editorData: timelineState.editorData,
-        settings: timelineState.settings,
-        duration: timelineState.totalDuration
-      });
-
-      const exportData = {
-        version: "1.0",
+      console.log("Exporting timeline data");
+      
+      const stateToExport = {
+        version: "2.0",
         timestamp: new Date().toISOString(),
         timeline: {
           clips: timelineState.clips.map(clip => {
-            // Find corresponding editor action to get current timeline position
-            const editorAction = timelineState.editorData?.actions?.find(
-              action => action.id === clip.id
-            );
-
-            console.log('Processing Clip:', {
-              clipId: clip.id,
-              clipData: clip,
-              editorAction: editorAction,
-              currentPosition: {
-                start: editorAction?.start,
-                end: editorAction?.end
-              }
-            });
+            // Get the stored metadata that was updated by TimelineClip
+            const metadata = clip.metadata || {};
+            const playback = metadata.playback || {};
+            const timeline = metadata.timeline || {};
 
             return {
               id: clip.id,
               source: {
-                startTime: clip.startTime,
-                endTime: clip.endTime,
-                duration: clip.duration,
-                name: clip.name
+                startTime: playback.start,  // Use stored playback times
+                endTime: playback.end,
+                duration: clip.source?.duration,
+                name: clip.file.name
               },
               file: {
                 name: clip.file.name,
@@ -46,63 +29,58 @@ const useTimelineExport = (timelineState) => {
                 type: clip.file.type
               },
               metadata: {
-                originalDuration: clip.duration,
+                originalDuration: clip.source?.duration,
                 timeline: {
-                  // Original media timing
-                  sourceStart: clip.startTime,
-                  sourceEnd: clip.endTime,
-                  // Current timeline positions
-                  start: editorAction?.start ?? 0,
-                  end: editorAction?.end ?? clip.duration
+                  sourceStart: clip.source?.startTime,
+                  sourceEnd: clip.source?.endTime,
+                  start: timeline.start,
+                  end: timeline.end,
+                  duration: timeline.duration
+                },
+                playback: {
+                  start: playback.start,
+                  end: playback.end,
+                  duration: playback.duration
                 }
               },
               position: {
-                timelineStart: editorAction?.start ?? 0,
-                timelineEnd: editorAction?.end ?? clip.duration,
-                row: editorAction?.data?.rowIndex ?? 0
+                timelineStart: timeline.start,
+                timelineEnd: timeline.end,
+                currentStart: playback.start,
+                currentEnd: playback.end,
+                track: timeline.track || 0
               },
               state: {
                 selected: clip.id === timelineState.selectedClipId,
-                effectId: editorAction?.effectId ?? 'default'
+                effectId: clip.effectId || 'default'
               }
             };
           }),
-          duration: timelineState.totalDuration || 0,
+          duration: timelineState.duration || 0,
           settings: {
-            scale: timelineState.settings?.scale,
-            effects: timelineState.settings?.effects
+            scale: timelineState.settings?.scale || 1,
+            effects: timelineState.settings?.effects || {}
           }
         }
       };
 
-      // Log the final export data with timing comparison
-      console.log('=== EXPORT DATA ANALYSIS ===');
-      exportData.timeline.clips.forEach(clip => {
-        console.log(`Clip ${clip.id} Timing Analysis:`, {
-          sourceTimings: {
-            start: clip.source.startTime,
-            end: clip.source.endTime,
-            duration: clip.source.duration
-          },
-          timelinePositions: {
-            start: clip.position.timelineStart,
-            end: clip.position.timelineEnd,
-            duration: clip.position.timelineEnd - clip.position.timelineStart
-          },
-          metadata: clip.metadata
-        });
+      // Debug logging
+      console.log('Timeline Export Data:', {
+        clipCount: stateToExport.timeline.clips.length,
+        clips: stateToExport.timeline.clips.map(clip => ({
+          id: clip.id,
+          timeline: `${clip.position.timelineStart}-${clip.position.timelineEnd}`,
+          playback: `${clip.position.currentStart}-${clip.position.currentEnd}`
+        }))
       });
 
-      const blob = new Blob([JSON.stringify(exportData, null, 2)], {
+      const blob = new Blob([JSON.stringify(stateToExport, null, 2)], {
         type: 'application/json'
       });
       
-      // Generate filename with timestamp
       const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
       const filename = `timeline_export_${timestamp}.json`;
       
-      console.log('Saving export file:', filename);
-
       const url = URL.createObjectURL(blob);
       const link = document.createElement('a');
       link.href = url;
@@ -112,16 +90,9 @@ const useTimelineExport = (timelineState) => {
       document.body.removeChild(link);
       URL.revokeObjectURL(url);
 
-      console.log('=== TIMELINE EXPORT COMPLETE ===');
     } catch (error) {
-      console.error('=== TIMELINE EXPORT ERROR ===');
-      console.error('Error details:', error);
-      console.error('Timeline State at error:', {
-        clips: timelineState.clips,
-        editorData: timelineState.editorData,
-        settings: timelineState.settings
-      });
-      throw new Error(`Failed to export timeline: ${error.message}`);
+      console.error('Failed to export timeline:', error);
+      throw error;
     }
   }, [timelineState]);
 
diff --git a/src/components/Timeline/TimelineSection.js b/src/components/Timeline/TimelineSection.js
index 0d31d2a..563e602 100644
--- a/src/components/Timeline/TimelineSection.js
+++ b/src/components/Timeline/TimelineSection.js
@@ -2,7 +2,7 @@
 import React from 'react';
 import { Box } from '@mui/material';
 import Timeline from './index';
-const TimelineSection = ({ clips, onClipsChange }) => {
+const TimelineSection = ({ clips, onClipsChange,timelineRows,setTimelineRows }) => {
   return (
     <Box sx={{ 
       width: '100%',
@@ -16,6 +16,8 @@ const TimelineSection = ({ clips, onClipsChange }) => {
       <Timeline 
         clips={clips}
         onClipsChange={onClipsChange}
+        timelineRows={timelineRows}
+        setTimelineRows={setTimelineRows}
       />
     </Box>
   );
diff --git a/src/components/Timeline/index.js b/src/components/Timeline/index.js
index 55820f5..0adb04e 100644
--- a/src/components/Timeline/index.js
+++ b/src/components/Timeline/index.js
@@ -19,6 +19,8 @@ const Timeline = ({
   onClipsChange,
   selectedClipId,
   onClipSelect,
+  timelineRows,
+  setTimelineRows,
 }) => {
   const { scale, handleZoomIn, handleZoomOut } = useTimelineZoom();
   const { editorData, effects, error } = useTimelineData(clips, onClipsChange);
@@ -26,123 +28,328 @@ const Timeline = ({
     // Add context menu state
     const [contextMenu, setContextMenu] = useState(null);
     const [selectedActionId, setSelectedActionId] = useState(null);
- 
-    // Handle move start
-  const handleMoveStart = useCallback(({ action, row }) => {
-    console.log('Move Start:', { action, row });
-    onClipSelect?.(action.id);
-  }, [onClipSelect]);
 
-  // Handle move
-  const handleMoving = useCallback(({ action, row, start, end }) => {
-    console.log('Moving:', { action, start, end });
-    // Return true to allow the move
-    return true;
-  }, []);
-
-  // Handle move end
-  const handleMoveEnd = useCallback(({ action, row, start, end }) => {
-    console.log('Move End:', { action, start, end });
+// Log incoming clips
+useEffect(() => {
+  if (clips.length > 0) {
+    console.log('Timeline clips:', clips);
+    // Log the last added clip
+    const lastClip = clips[clips.length - 1];
+    console.log('Latest clip:', {
+      clipData: lastClip,
+      trimmedPortion: {
+        start: lastClip.startTime,
+        end: lastClip.endTime,
+        duration: lastClip.duration
+      },
+      sourceInfo: lastClip.source
+    });
+  }
+}, [clips]);
+
+
+  // Handle general changes
+  // Update the handleChange callback in Timeline component
+  const handleChange = useCallback((newEditorData) => {
+    console.log('Timeline Changed:', newEditorData);
     
-    // Update the clips with new positions
+    if (!newEditorData?.actions) return;
+  
     const updatedClips = clips.map(clip => {
-      if (clip.id === action.id) {
-        return {
-          ...clip,
-          metadata: {
-            ...clip.metadata,
-            timeline: {
-              start,
-              end,
-              duration: end - start
-            }
+      const action = newEditorData.actions.find(a => a.id === clip.id);
+      if (!action) return clip;
+  
+      // Get the current metadata from the action data or initialize it
+      const actionData = action.data || {};
+      const metadata = actionData.metadata || {};
+      const timeline = metadata.timeline || {};
+      const playback = metadata.playback || {};
+  
+      // Initialize timeline metadata if not present
+      const hasTimelineMetadata = Object.keys(timeline).length > 0;
+      const timelineStart = hasTimelineMetadata ? timeline.start : action.start;
+      const timelineEnd = hasTimelineMetadata ? timeline.end : action.end;
+      const timelineDuration = timelineEnd - timelineStart;
+  
+      // Initialize playback metadata if not present
+      const hasPlaybackMetadata = Object.keys(playback).length > 0;
+      const playbackStart = hasPlaybackMetadata ? playback.start : clip.startTime;
+      const playbackEnd = hasPlaybackMetadata ? playback.end : clip.endTime;
+      const playbackDuration = playbackEnd - playbackStart;
+  
+      return {
+        ...clip,
+        ...actionData,
+        startTime: playbackStart,
+        endTime: playbackEnd,
+        metadata: {
+          ...metadata,
+          timeline: {
+            start: timelineStart,
+            end: timelineEnd,
+            duration: timelineDuration,
+          },
+          playback: {
+            start: playbackStart,
+            end: playbackEnd,
+            duration: playbackDuration
           }
-        };
-      }
-      return clip;
+        }
+      };
     });
-
+  
+    console.log('Updated clips with metadata:', updatedClips);
     onClipsChange(updatedClips);
   }, [clips, onClipsChange]);
+  
+  
+    // Timeline state export functionality
+    const timelineState = {
+      clips: clips.map(clip => ({
+        ...clip,
+        timelinePosition: clip.metadata?.timeline || {}
+      })),
+      totalDuration: editorData.duration,
+      settings: { scale, effects }
+    };
+    
 
-    // Handle resize start
-    const handleResizeStart = useCallback(({ action, row, dir }) => {
-      console.log('Resize Start:', { action, dir });
-      
-      // Update the action data with the resize direction
-      action.data = {
-        ...action.data,
-        resizeDir: dir
-      };
-      
-      onClipSelect?.(action.id);
-    }, [onClipSelect]);
+  // Handle move start
+const handleMoveStart = useCallback(({ action, row }) => {
+  console.log('Move Start:', { action, row });
+  
+  // Store initial state like we do in resize
+  action.data = {
+    ...action.data,
+    initialStart: action.start,
+    initialEnd: action.end,
+    metadata: {
+      ...action.data.metadata,
+      timeline: {
+        start: action.start,
+        end: action.end,
+        duration: action.end - action.start
+      }
+    }
+  };
+  
+  onClipSelect?.(action.id);
+}, [onClipSelect]);
+  // Handle move
+ // Handle move
+const handleMoving = useCallback(({ action, row, start, end }) => {
+  console.log('Moving:', { action, start, end });
   
-    // Handle resizing
-    const handleResizing = useCallback(({ action, row, start, end, dir }) => {
-      console.log('Resizing:', { action, start, end, dir });
-      
-      // Update the action data with current resize info
-      action.data = {
-        ...action.data,
-        resizeDir: dir
+  // Update both timeline and playback metadata during move
+  action.data = {
+    ...action.data,
+    metadata: {
+      ...action.data.metadata,
+      timeline: {
+        start,
+        end,
+        duration: end - start,
+        initialStart: action.data.metadata?.timeline?.initialStart
+      },
+      playback: {
+        start: action.data.metadata?.playback?.start || action.data.startTime,
+        end: action.data.metadata?.playback?.end || action.data.endTime,
+        duration: action.data.metadata?.playback?.duration || (action.data.endTime - action.data.startTime)
+      }
+    }
+  };
+  console.log('Moving clip:', {
+    timeline: { start, end, duration: end - start },
+    playback: { 
+      start: action.data.metadata?.playback?.start || action.data.startTime,
+      end: action.data.metadata?.playback?.end || action.data.endTime 
+    }
+  });
+  
+  return true;
+}, []);
+
+ // Handle move end
+const handleMoveEnd = useCallback(({ action, row, start, end }) => {
+  console.log('Move End:', { action, start, end });
+
+
+  const updatedClips = clips.map(clip => {
+    if (clip.id === action.id) {
+      const actionData = action.data || {};
+      const metadata = actionData.metadata || {};
+      const playback = metadata.playback || {};
+      return {
+        ...clip,
+        ...actionData,
+        startTime: playback.start || clip.startTime,
+        endTime: playback.end || clip.endTime,
+        metadata: {
+          ...metadata,
+          timeline: {
+            ...metadata.timeline,
+            start,
+            end,
+            duration: end - start
+          }
+        }
       };
-      
-      return true;
-    }, []);
+    }
+    return clip;
+  });
+
+  onClipsChange(updatedClips);
+}, [clips, onClipsChange]);
+
   
+
+
+// Handle resize start
+const handleResizeStart = useCallback(({ action, row, dir }) => {
+  console.log('Resize Start:', { action, dir });
+  
+  // Update the action data with the resize direction
+  action.data = {
+    ...action.data,
+    resizeDir: dir
+  };
+  
+  onClipSelect?.(action.id);
+}, [onClipSelect]);
+
+
+// Handle resizing
+const handleResizing = useCallback(({ action, row, start, end, dir }) => {
+  console.log('Resizing:', { action, start, end, dir });
+
+  // Get source video bounds
+  const sourceStart = action.data.source.startTime; // 0
+  const sourceEnd = action.data.source.endTime;     // 42.944
+
+  // Check if resize would exceed bounds
+  if (dir === 'left' && start < sourceStart) {
+    return false; // Prevent resizing below source start
+  }
+  if (dir === 'right' && end > sourceEnd) {
+    return false; // Prevent resizing beyond source end
+  }
+
+  // Calculate new playback times based on resize direction
+  let playbackStart = action.data.metadata?.playback?.start || action.data.startTime;
+  let playbackEnd = action.data.metadata?.playback?.end || action.data.endTime;
+  const timelineDuration = end - start;
+
+  if (dir === 'left') {
+    playbackEnd = action.data.metadata?.playback?.end || action.data.endTime;
+    playbackStart = playbackEnd - timelineDuration;
+  } else if (dir === 'right') {
+    playbackStart = action.data.metadata?.playback?.start || action.data.startTime;
+    playbackEnd = playbackStart + timelineDuration;
+  }
+
+  // Ensure playback times stay within source bounds
+  playbackStart = Math.max(playbackStart, sourceStart);
+  playbackEnd = Math.min(playbackEnd, sourceEnd);
+
+  // Update action.data to reflect the resized clip
+  action.data = {
+    ...action.data,
+    resizeDir: dir,
+    metadata: {
+      ...action.data.metadata,
+      timeline: {
+        start,
+        end,
+        duration: end - start,
+      },
+      playback: {
+        start: playbackStart,
+        end: playbackEnd,
+        duration: playbackEnd - playbackStart
+      }
+    }
+  };
+
+  console.log('Updated clip timing:', {
+    timeline: { start, end, duration: end - start },
+    playback: { start: playbackStart, end: playbackEnd, duration: playbackEnd - playbackStart }
+  });
+
+  return true;
+}, []);
+
+
 // Handle resize end
 const handleResizeEnd = useCallback(({ action, row, start, end, dir }) => {
   console.log('Resize End:', { action, start, end, dir });
-  
-  const updatedClips = clips.map(clip => {
-      if (clip.id === action.id) {
-          // Use all the data we calculated during resize
-          return {
-              ...clip,
-              ...action.data,  // This includes the updated startTime, endTime
-              metadata: {
-                  ...action.data.metadata,  // Use the metadata we calculated during resize
+
+  // Get source video bounds
+  const sourceStart = action.data.source.startTime;
+  const sourceEnd = action.data.source.endTime;
+
+  // Ensure the final start and end times are clamped within the source bounds
+  start = Math.max(start, sourceStart);
+  end = Math.min(end, sourceEnd);
+
+  // Create updated editorData
+  const updatedEditorData = editorData.map(r => {
+    if (r.id === row.id) {
+      return {
+        ...r,
+        actions: r.actions.map(a => {
+          if (a.id === action.id) {
+            const updatedAction = {
+              ...a,
+              start,
+              end,
+              data: {
+                ...a.data,
+                metadata: {
+                  ...a.data?.metadata,
                   timeline: {
-                      start,
-                      end,
-                      duration: end - start
+                    ...a.data?.metadata?.timeline,
+                    start,
+                    end,
+                    duration: end - start
                   }
+                }
               }
-          };
-      }
-      return clip;
+            };
+            return updatedAction;
+          }
+          return a;
+        })
+      };
+    }
+    return r;
   });
 
-  onClipsChange(updatedClips);
-}, [clips, onClipsChange]);
-
-  // Handle general changes
-  const handleChange = useCallback((newEditorData) => {
-    console.log('Timeline Changed:', newEditorData);
-    
-    if (!newEditorData?.actions) return;
-
-    const updatedClips = clips.map(clip => {
-      const action = newEditorData.actions.find(a => a.id === clip.id);
-      if (!action) return clip;
+  // Call handleChange with the updated editor data
+  handleChange(updatedEditorData);
 
+  // Also update the clips array
+  const updatedClips = clips.map(clip => {
+    if (clip.id === action.id) {
       return {
         ...clip,
-        metadata: action.data?.metadata || clip.metadata
+        metadata: {
+          ...clip.metadata,
+          timeline: {
+            ...clip.metadata?.timeline,
+            start,
+            end,
+            duration: end - start
+          }
+        }
       };
-    });
+    }
+    return clip;
+  });
+
+  onClipsChange(updatedClips);
+}, [clips, editorData, handleChange, onClipsChange]);
 
-    onClipsChange(updatedClips);
-  }, [clips, onClipsChange]);
 
-  // Timeline state export functionality
-  const timelineState = {
-    clips,
-    totalDuration: editorData.duration,
-    settings: { scale, effects }
-  };
-  
   const { exportTimelineData } = useTimelineExport(timelineState);
 
   // Enhanced debug handler
@@ -168,19 +375,74 @@ const handleResizeEnd = useCallback(({ action, row, start, end, dir }) => {
     console.log('Context Menu State:', { position: { x: e.clientX, y: e.clientY }, selectedActionId: action.id });
   }, [onClipSelect]);
 
-  // Delete handler with logging
-  const handleDelete = useCallback(() => {
-    console.log('=== DELETE HANDLER ===');
-    console.log('Selected Action ID:', selectedActionId);
-    
-    if (selectedActionId) {
-      const newClips = clips.filter(clip => clip.id !== selectedActionId);
-      console.log('Updated Clips:', newClips);
-      onClipsChange(newClips);
-      setContextMenu(null);
-      setSelectedActionId(null);
+ // Helper function to recalculate positions and lastEnd for each row
+const recalculateTimelineState = (clipsArray) => {
+  // Group clips by row
+  const rowsMap = new Map();
+  
+  clipsArray.forEach(clip => {
+    const rowIndex = clip.metadata.timeline.row;
+    if (!rowsMap.has(rowIndex)) {
+      rowsMap.set(rowIndex, []);
     }
-  }, [clips, selectedActionId, onClipsChange]);
+    rowsMap.get(rowIndex).push(clip);
+  });
+
+  // Sort clips within each row and update positions
+  rowsMap.forEach((rowClips, rowIndex) => {
+    rowClips.sort((a, b) => a.metadata.timeline.start - b.metadata.timeline.start);
+    
+    let currentPosition = 0;
+    rowClips.forEach(clip => {
+      // Update clip timeline metadata
+      clip.metadata.timeline = {
+        ...clip.metadata.timeline,
+        start: currentPosition,
+        end: currentPosition + clip.metadata.timeline.duration
+      };
+      currentPosition = clip.metadata.timeline.end;
+    });
+  });
+
+  // Flatten back to array and return
+  return Array.from(rowsMap.values()).flat();
+};
+
+// Updated delete handler
+const handleDelete = useCallback(() => {
+  console.log('=== DELETE HANDLER ===');
+  console.log('Selected Action ID:', selectedActionId);
+  
+  if (selectedActionId) {
+    // Filter out the deleted clip
+    const newClips = clips.filter(clip => clip.id !== selectedActionId);
+    
+    // Recalculate all positions and update timeline state
+    const updatedClips = recalculateTimelineState(newClips);
+    
+    // Update the lastEnd values for each row in timelineRows
+    const updatedTimelineRows = timelineRows.map(row => {
+      const rowClips = updatedClips.filter(clip => 
+        clip.metadata.timeline.row === row.rowId
+      );
+      return {
+        ...row,
+        clips: rowClips,
+        lastEnd: rowClips.length > 0 
+          ? Math.max(...rowClips.map(clip => clip.metadata.timeline.end))
+          : 0
+      };
+    });
+    
+    console.log('Updated Clips with new positions:', updatedClips);
+    
+    // Update states
+    setTimelineRows(updatedTimelineRows);
+    onClipsChange(updatedClips);
+    setContextMenu(null);
+    setSelectedActionId(null);
+  }
+}, [clips, selectedActionId, onClipsChange, setTimelineRows,timelineRows]);
 
   // Keyboard delete handler with logging
   useEffect(() => {
@@ -217,6 +479,8 @@ const handleResizeEnd = useCallback(({ action, row, start, end, dir }) => {
         scale={scale}
         onZoomIn={handleZoomIn}
         onZoomOut={handleZoomOut}
+        timelineState={timelineState} 
+        selectedClipId={selectedClipId} 
         onDownloadState={exportTimelineData}
         onDebugClips={handleDebug}
       />
@@ -265,6 +529,9 @@ const handleResizeEnd = useCallback(({ action, row, start, end, dir }) => {
         onActionMoveStart={handleMoveStart}
         onActionMoving={handleMoving}
         onActionMoveEnd={handleMoveEnd}
+        // Add collision detection properties
+        allowOverlap={true} // Prevent clips from overlapping
+        pushOnOverlap={true} // Push clips when they collide
         // Resize handlers
         onActionResizeStart={handleResizeStart}
         onActionResizing={handleResizing}
@@ -281,6 +548,7 @@ const handleResizeEnd = useCallback(({ action, row, start, end, dir }) => {
         scale={1}
         minScaleCount={20}
         scaleSplitCount={10}
+        snapThreshold={5}
         getActionRender={(action, row) => (
           <Box onContextMenu={(e) => handleContextMenu(e, action)}>
             <TimelineClip
diff --git a/src/components/TimelineTransition/TimelineTransitionContainer.js b/src/components/TimelineTransition/TimelineTransitionContainer.js
new file mode 100644
index 0000000..8a77843
--- /dev/null
+++ b/src/components/TimelineTransition/TimelineTransitionContainer.js
@@ -0,0 +1,31 @@
+// src/components/TimelineTransition/TimelineTransitionContainer.js
+import React from 'react';
+import { Box } from '@mui/material';
+import { useTimelineTransition } from '../../hooks/useTimeline/useTimelineTransition';
+import { TimelineTransitionPlayer } from './TimelineTransitionPlayer';
+
+export const TimelineTransitionContainer = ({ 
+  clips, 
+  currentTime, 
+  playing,
+  onClipProgress 
+}) => {
+  const { 
+    activeClips, 
+    playbackStates 
+  } = useTimelineTransition(clips, currentTime, playing);
+
+  return (
+    <Box sx={{ position: 'relative', width: '100%', height: '100%' }}>
+      {activeClips.map((clip, index) => (
+        <TimelineTransitionPlayer
+          key={clip.id}
+          clip={clip}
+          playbackState={playbackStates[clip.id]}
+          zIndex={index}
+          onProgress={(progress) => onClipProgress?.(clip.id, progress)}
+        />
+      ))}
+    </Box>
+  );
+};
\ No newline at end of file
diff --git a/src/components/TimelineTransition/TimelineTransitionPlayer.js b/src/components/TimelineTransition/TimelineTransitionPlayer.js
new file mode 100644
index 0000000..d20d825
--- /dev/null
+++ b/src/components/TimelineTransition/TimelineTransitionPlayer.js
@@ -0,0 +1,46 @@
+import React from 'react';
+import { Box } from '@mui/material';
+import ReactPlayer from 'react-player';
+
+const TRANSITION_DURATION = 500;
+
+export const TimelineTransitionPlayer = ({ 
+  clip, 
+  playbackState = {}, // Provide a default empty object
+  onProgress,
+  zIndex 
+}) => {
+  // Destructure opacity and playing with default values
+  const { opacity = 0, playing = false } = playbackState;
+
+  return (
+    <Box
+      sx={{
+        position: 'absolute',
+        top: 0,
+        left: 0,
+        width: '100%',
+        height: '100%',
+        opacity: opacity, // Now this will default to 0 if undefined
+        transition: `opacity ${TRANSITION_DURATION}ms ease-in-out`,
+        zIndex
+      }}
+    >
+      <ReactPlayer
+        url={clip.url}
+        playing={playing} // Now this will default to false if undefined
+        width="100%"
+        height="100%"
+        progressInterval={100}
+        onProgress={onProgress}
+        config={{
+          file: {
+            attributes: {
+              crossOrigin: "anonymous"
+            }
+          }
+        }}
+      />
+    </Box>
+  );
+};
diff --git a/src/components/TimelineTransition/index.js b/src/components/TimelineTransition/index.js
new file mode 100644
index 0000000..166a289
--- /dev/null
+++ b/src/components/TimelineTransition/index.js
@@ -0,0 +1,14 @@
+// src/components/TimelineTransition/index.js
+
+// Import the components
+import TimelineTransitionPlayer from './TimelineTransitionPlayer';
+import TimelineTransitionContainer from './TimelineTransitionContainer';
+
+// Export the components
+export { TimelineTransitionPlayer, TimelineTransitionContainer };
+
+// Optionally, you can also do a default export of both as a named object
+export default {
+  TimelineTransitionPlayer,
+  TimelineTransitionContainer
+};
diff --git a/src/components/TimelineViewer.js b/src/components/TimelineViewer.js
deleted file mode 100644
index fc542d4..0000000
--- a/src/components/TimelineViewer.js
+++ /dev/null
@@ -1,380 +0,0 @@
-import React, { useState, useEffect, useRef, useCallback, useMemo } from 'react';
-import ReactPlayer from 'react-player';
-import { Box, Typography, LinearProgress, IconButton, Tooltip } from '@mui/material';
-// eslint-disable-next-line no-unused-vars
-import { Button } from '@mui/material';
-import { PlayCircle, PauseCircle, SkipNext, SkipPrevious, Replay } from '@mui/icons-material';
-
-// Constants
-const PROGRESS_INTERVAL = 100; // ms
-const PRELOAD_THRESHOLD = 0.9; // Start preloading next clip when current is 90% complete
-const TRANSITION_DURATION = 500; // ms for crossfade between clips
-
-const TimelineViewer = ({ clips = [], onPlaybackComplete }) => {
-  // State
-  const [playing, setPlaying] = useState(false);
-  const [currentClipIndex, setCurrentClipIndex] = useState(0);
-  const [progress, setProgress] = useState(0);
-  const [isTransitioning, setIsTransitioning] = useState(false);
-  const [error, setError] = useState(null);
-  const [currentUrl, setCurrentUrl] = useState(null);
-  const [nextUrl, setNextUrl] = useState(null);
-
-  // Refs
-  const playerRef = useRef(null);
-  const nextPlayerRef = useRef(null);
-  const urlsRef = useRef({ current: null, next: null });
-  const transitionTimeoutRef = useRef(null);
-
-  // Memoized calculations
-  const totalDuration = useMemo(() => {
-    return clips.reduce((total, clip) => total + (clip.endTime - clip.startTime), 0);
-  }, [clips]);
-
-  const currentClip = useMemo(() => clips[currentClipIndex], [clips, currentClipIndex]);
-  
-  const nextClip = useMemo(() => clips[currentClipIndex + 1], [clips, currentClipIndex]);
-
-  // Cleanup function for URL objects
-  const cleanupUrls = useCallback(() => {
-    if (urlsRef.current.current) {
-      URL.revokeObjectURL(urlsRef.current.current);
-    }
-    if (urlsRef.current.next) {
-      URL.revokeObjectURL(urlsRef.current.next);
-    }
-    urlsRef.current = { current: null, next: null };
-  }, []);
-
-  // Initialize or reset playback
-  useEffect(() => {
-    if (clips.length > 0) {
-      setCurrentClipIndex(0);
-      setProgress(0);
-      setPlaying(false);
-      setError(null);
-      
-      // Clean up existing URLs
-      cleanupUrls();
-
-      // Create new URL for current clip
-      if (clips[0]?.file) {
-        try {
-          const url = URL.createObjectURL(clips[0].file);
-          urlsRef.current.current = url;
-          setCurrentUrl(url);
-
-          // Preload next clip if available
-          if (clips[1]?.file) {
-            const nextUrl = URL.createObjectURL(clips[1].file);
-            urlsRef.current.next = nextUrl;
-            setNextUrl(nextUrl);
-          }
-        } catch (err) {
-          setError(`Failed to load video: ${err.message}`);
-        }
-      }
-    }
-
-    return cleanupUrls;
-  }, [clips, cleanupUrls]);
-
-  // Handle clip transitions
-  const handleClipTransition = useCallback(async () => {
-    if (currentClipIndex >= clips.length - 1) {
-      setPlaying(false);
-      setCurrentClipIndex(0);
-      onPlaybackComplete?.();
-      return;
-    }
-
-    setIsTransitioning(true);
-    
-    // Move to next clip
-    const nextIndex = currentClipIndex + 1;
-    setCurrentClipIndex(nextIndex);
-
-    // Clean up current URL and set next URL as current
-    if (urlsRef.current.current) {
-      URL.revokeObjectURL(urlsRef.current.current);
-    }
-    urlsRef.current.current = urlsRef.current.next;
-    setCurrentUrl(nextUrl);
-
-    // Preload next clip if available
-    if (clips[nextIndex + 1]?.file) {
-      try {
-        const newNextUrl = URL.createObjectURL(clips[nextIndex + 1].file);
-        urlsRef.current.next = newNextUrl;
-        setNextUrl(newNextUrl);
-      } catch (err) {
-        console.error('Failed to preload next clip:', err);
-      }
-    } else {
-      urlsRef.current.next = null;
-      setNextUrl(null);
-    }
-
-    // Handle transition timing
-    // eslint-disable-next-line react-hooks/exhaustive-deps
-    transitionTimeoutRef.current = setTimeout(() => {
-      setIsTransitioning(false);
-    }, TRANSITION_DURATION);
-  }, [currentClipIndex, clips, nextUrl, onPlaybackComplete]);
-
-  // Progress handling
-  const handleProgress = useCallback(({ played, playedSeconds }) => {
-    if (!currentClip || isTransitioning) return;
-
-    const clipDuration = currentClip.endTime - currentClip.startTime;
-    const currentTime = currentClip.startTime + played * clipDuration;
-    setProgress(currentTime);
-
-    // Handle clip completion
-    if (playedSeconds >= clipDuration) {
-      handleClipTransition();
-    }
-    // Preload next clip
-    else if (played > PRELOAD_THRESHOLD && nextClip && !nextUrl) {
-      try {
-        const newNextUrl = URL.createObjectURL(nextClip.file);
-        urlsRef.current.next = newNextUrl;
-        setNextUrl(newNextUrl);
-      } catch (err) {
-        console.error('Failed to preload next clip:', err);
-      }
-    }
-  }, [currentClip, isTransitioning, handleClipTransition, nextClip, nextUrl]);
-
-  // Playback controls
-  const handlePlayPause = useCallback(() => {
-    if (error) return;
-    setPlaying(!playing);
-  }, [error, playing]);
-
-  const handlePrevClip = useCallback(() => {
-    if (currentClipIndex > 0) {
-      setCurrentClipIndex(prev => prev - 1);
-      setPlaying(false);
-    }
-  }, [currentClipIndex]);
-
-  const handleNextClip = useCallback(() => {
-    if (currentClipIndex < clips.length - 1) {
-      handleClipTransition();
-      setPlaying(false);
-    }
-  }, [currentClipIndex, clips.length, handleClipTransition]);
-
-  const handleRestart = useCallback(() => {
-    setCurrentClipIndex(0);
-    setProgress(0);
-    setPlaying(false);
-  }, []);
-
-  // Error handling
-  const handleError = useCallback((e) => {
-    console.error('Playback error:', e);
-    setError('Failed to play video. Please try again.');
-    setPlaying(false);
-  }, []);
-
-  // Cleanup on unmount
-  useEffect(() => {
-    return () => {
-      cleanupUrls();
-      if (transitionTimeoutRef.current) {
-        clearTimeout(transitionTimeoutRef.current);
-      }
-    };
-  }, [cleanupUrls]);
-
-  // Format time for display
-  const formatTime = useCallback((time) => {
-    const minutes = Math.floor(time / 60);
-    const seconds = Math.floor(time % 60);
-    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
-  }, []);
-
-  // Empty state
-  if (clips.length === 0) {
-    return (
-      <Box sx={{ 
-        height: '100%', 
-        display: 'flex', 
-        alignItems: 'center', 
-        justifyContent: 'center',
-        bgcolor: 'background.paper',
-        borderRadius: 1,
-      }}>
-        <Typography color="text.secondary">No clips in timeline</Typography>
-      </Box>
-    );
-  }
-
-  return (
-    <Box sx={{ 
-      height: '100%', 
-      display: 'flex', 
-      flexDirection: 'column',
-      bgcolor: 'background.paper',
-      borderRadius: 1,
-      overflow: 'hidden'
-    }}>
-      <Box sx={{ 
-        flexGrow: 1, 
-        position: 'relative',
-        bgcolor: 'black',
-      }}>
-        {/* Current clip player */}
-        {currentUrl && (
-          <Box sx={{ 
-            position: 'absolute',
-            top: 0,
-            left: 0,
-            right: 0,
-            bottom: 0,
-            opacity: isTransitioning ? 0 : 1,
-            transition: `opacity ${TRANSITION_DURATION}ms ease-in-out`
-          }}>
-            <ReactPlayer
-              ref={playerRef}
-              url={currentUrl}
-              width="100%"
-              height="100%"
-              playing={playing && !isTransitioning}
-              onProgress={handleProgress}
-              onError={handleError}
-              progressInterval={PROGRESS_INTERVAL}
-              config={{
-                file: {
-                  attributes: {
-                    crossOrigin: "anonymous"
-                  }
-                }
-              }}
-            />
-          </Box>
-        )}
-
-        {/* Next clip player (for smooth transitions) */}
-        {nextUrl && (
-          <Box sx={{ 
-            position: 'absolute',
-            top: 0,
-            left: 0,
-            right: 0,
-            bottom: 0,
-            opacity: isTransitioning ? 1 : 0,
-            transition: `opacity ${TRANSITION_DURATION}ms ease-in-out`
-          }}>
-            <ReactPlayer
-              ref={nextPlayerRef}
-              url={nextUrl}
-              width="100%"
-              height="100%"
-              playing={playing && isTransitioning}
-              progressInterval={PROGRESS_INTERVAL}
-              config={{
-                file: {
-                  attributes: {
-                    crossOrigin: "anonymous"
-                  }
-                }
-              }}
-            />
-          </Box>
-        )}
-
-        {/* Error overlay */}
-        {error && (
-          <Box sx={{
-            position: 'absolute',
-            top: 0,
-            left: 0,
-            right: 0,
-            bottom: 0,
-            bgcolor: 'rgba(0, 0, 0, 0.7)',
-            display: 'flex',
-            alignItems: 'center',
-            justifyContent: 'center',
-            p: 2,
-          }}>
-            <Typography color="error" align="center">
-              {error}
-            </Typography>
-          </Box>
-        )}
-      </Box>
-
-      {/* Progress bar */}
-      <LinearProgress 
-        variant="determinate" 
-        value={(progress / totalDuration) * 100} 
-        sx={{ 
-          height: 4,
-          '& .MuiLinearProgress-bar': {
-            transition: 'none'
-          }
-        }}
-      />
-
-      {/* Controls */}
-      <Box sx={{ 
-        p: 2,
-        display: 'flex', 
-        alignItems: 'center',
-        gap: 2
-      }}>
-        <Box sx={{ flexGrow: 1, display: 'flex', alignItems: 'center', gap: 1 }}>
-          <Tooltip title="Restart">
-            <IconButton onClick={handleRestart} size="small">
-              <Replay />
-            </IconButton>
-          </Tooltip>
-          <Tooltip title="Previous Clip">
-            <span>
-              <IconButton 
-                onClick={handlePrevClip} 
-                disabled={currentClipIndex === 0}
-                size="small"
-              >
-                <SkipPrevious />
-              </IconButton>
-            </span>
-          </Tooltip>
-          <IconButton onClick={handlePlayPause} disabled={!!error} size="large">
-            {playing ? <PauseCircle /> : <PlayCircle />}
-          </IconButton>
-          <Tooltip title="Next Clip">
-            <span>
-              <IconButton 
-                onClick={handleNextClip}
-                disabled={currentClipIndex === clips.length - 1}
-                size="small"
-              >
-                <SkipNext />
-              </IconButton>
-            </span>
-          </Tooltip>
-        </Box>
-        
-        <Box sx={{ 
-          display: 'flex', 
-          alignItems: 'center', 
-          gap: 2,
-          color: 'text.secondary'
-        }}>
-          <Typography variant="body2">
-            Clip: {currentClipIndex + 1} / {clips.length}
-          </Typography>
-          <Typography variant="body2">
-            {formatTime(progress)} / {formatTime(totalDuration)}
-          </Typography>
-        </Box>
-      </Box>
-    </Box>
-  );
-};
-
-export default TimelineViewer;
\ No newline at end of file
diff --git a/src/components/BinViewer.js b/src/components/Viewers/BinViewer.js
similarity index 82%
rename from src/components/BinViewer.js
rename to src/components/Viewers/BinViewer.js
index ac47194..34c57bb 100644
--- a/src/components/BinViewer.js
+++ b/src/components/Viewers/BinViewer.js
@@ -10,7 +10,7 @@ const MIN_CLIP_DURATION = 1; // minimum clip duration in seconds
 const SEEK_DEBOUNCE_MS = 100; // debounce delay for seeking
 const PROGRESS_INTERVAL = 100; // progress update interval in ms
 
-const BinViewer = ({ selectedClip, onAddToTimeline }) => {
+const BinViewer = ({ clips, selectedClip, onAddToTimeline, setTimelineRows}) => {
   // State management
   const [playing, setPlaying] = useState(false);
   const [duration, setDuration] = useState(0);
@@ -113,17 +113,58 @@ const BinViewer = ({ selectedClip, onAddToTimeline }) => {
 
   const handleAddToTimeline = () => {
     if (!selectedClip || error) return;
-
+  
+    const clipStart = range[0];
+    const clipEnd = range[1];
+    const timelineDuration = clipEnd - clipStart;
+  
+    // Find the end position of the last clip in the timeline
+    const findTimelineEndPosition = (clips) => {
+      if (!clips.length) return 0;
+      return Math.max(...clips.map(clip => clip.metadata.timeline.end));
+    };
+  
+    // Calculate where this clip should start in the timeline
+    const timelineStart = findTimelineEndPosition(clips); // Using clips from props/state
+    const timelineEnd = timelineStart + timelineDuration;
+    
+    // Create clip data with timeline metadata
     const clipData = {
-      id: `clip-${Date.now()}`, // Generate unique ID
+      id: `clip-${Date.now()}`,
       file: selectedClip.file,
       name: selectedClip.file.name,
-      startTime: range[0],
-      endTime: range[1],
-      duration: range[1] - range[0]
+      startTime: clipStart,
+      endTime: clipEnd,
+      duration: timelineDuration,
+      source: {
+        startTime: 0,
+        endTime: duration,
+        duration: duration
+      },
+      metadata: {
+        timeline: {
+          start: timelineStart,
+          end: timelineEnd,
+          duration: timelineDuration,
+          row: 0 // Always use row 0 as before
+        },
+        playback: {
+          start: clipStart,
+          end: clipEnd,
+          duration: timelineDuration
+        }
+      }
     };
-
+  
+    // Call the callback function to add clip to the main timeline
     onAddToTimeline?.(clipData);
+    
+    console.log('Adding clip with metadata:', {
+      clip: clipData,
+      timeline: clipData.metadata.timeline,
+      playback: clipData.metadata.playback,
+      rowIndex: 0
+    });
   };
 
   const formatTime = (time) => {
diff --git a/src/components/Viewers/BinViewerSection.js b/src/components/Viewers/BinViewerSection.js
index c036460..cba5f44 100644
--- a/src/components/Viewers/BinViewerSection.js
+++ b/src/components/Viewers/BinViewerSection.js
@@ -1,15 +1,116 @@
-// src/components/Viewers/BinViewerSection.js
-import React from 'react';
-import { Paper } from '@mui/material';
-import BinViewer from '../BinViewer';
-const BinViewerSection = ({ selectedClip, onAddToTimeline }) => {
+import React, { useState } from 'react';
+import { 
+  Box, 
+  Paper, 
+  Typography,
+  Tabs,
+  Tab,
+} from '@mui/material';
+import VideoFileIcon from '@mui/icons-material/VideoFile';
+import TextSnippetIcon from '@mui/icons-material/TextSnippet';
+import BinViewer from './BinViewer';import TranscriptViewer from './TranscriptViewer';
+
+
+const BinViewerSection = ({ 
+  clips,
+  selectedClip, 
+  onAddToTimeline,
+  transcriptData,
+  timelineState,
+  onTranscriptUpload,
+}) => {
+  const [viewMode, setViewMode] = useState(0);
+  const [timelineRows, setTimelineRows] = useState([{ rowId: 0, clips: [], lastEnd: 0 }]);
+
+  // Modified add to timeline handler to update timelineRows
+  const handleAddToTimeline = (clipData) => {
+    // Call the parent's onAddToTimeline
+    onAddToTimeline?.(clipData);
+    
+    // Update local timelineRows state if needed
+    setTimelineRows(prev => {
+      const rowIndex = clipData.metadata.timeline.row;
+      const updated = [...prev];
+      while (updated.length <= rowIndex) {
+        updated.push({ rowId: updated.length, clips: [], lastEnd: 0 });
+      }
+      const targetRow = updated[rowIndex];
+      targetRow.clips.push(clipData);
+      targetRow.lastEnd = Math.max(targetRow.lastEnd, clipData.metadata.timeline.end);
+      return updated;
+    });
+  };
+
   return (
-    <Paper sx={{ flex: 1, p: 2, bgcolor: 'background.paper' }}>
-      <BinViewer
-        selectedClip={selectedClip}
-        onAddToTimeline={onAddToTimeline}
-      />
+    <Paper 
+      sx={{ 
+        flex: 1, 
+        display: 'flex',
+        flexDirection: 'column',
+        bgcolor: 'background.paper',
+        overflow: 'hidden'
+      }}
+    >
+      {/* Single header with view toggle */}
+      <Box sx={{ 
+        p: 2,
+        borderBottom: 1, 
+        borderColor: 'divider',
+        display: 'flex',
+        alignItems: 'center',
+        justifyContent: 'space-between',
+      }}>
+        <Typography variant="subtitle1">
+          Bin Viewer
+        </Typography>
+        <Tabs 
+          value={viewMode} 
+          onChange={(e, newValue) => setViewMode(newValue)}
+          sx={{ minHeight: 48 }}
+        >
+          <Tab
+            icon={<VideoFileIcon />}
+            iconPosition="start"
+            label="Video"
+            sx={{ minHeight: 48 }}
+          />
+          <Tab
+            icon={<TextSnippetIcon />}
+            iconPosition="start"
+            label="Transcript"
+            disabled={!transcriptData}
+            sx={{ minHeight: 48 }}
+          />
+        </Tabs>
+      </Box>
+
+      {/* Content area */}
+      <Box sx={{ 
+        flex: 1, 
+        position: 'relative',
+        overflow: 'hidden'
+      }}>
+        {viewMode === 0 ? (
+          <BinViewer
+            clips={clips}
+            selectedClip={selectedClip}
+            onAddToTimeline={handleAddToTimeline}
+            timelineRows={timelineRows}
+            setTimelineRows={setTimelineRows}
+          />
+        ) : (
+          <TranscriptViewer
+            clips={clips}
+            selectedClip={selectedClip}
+            transcriptData={transcriptData}
+            onAddToTimeline={handleAddToTimeline}
+            timelineRows={timelineRows}
+            setTimelineRows={setTimelineRows}
+          />
+        )}
+      </Box>
     </Paper>
   );
 };
+
 export default BinViewerSection;
\ No newline at end of file
diff --git a/src/components/Viewers/TimelineTranscriptViewer.js b/src/components/Viewers/TimelineTranscriptViewer.js
new file mode 100644
index 0000000..fb42a64
--- /dev/null
+++ b/src/components/Viewers/TimelineTranscriptViewer.js
@@ -0,0 +1,294 @@
+import React, { useState, useCallback, useEffect, useRef } from 'react';
+import { 
+  Box, 
+  Card, 
+  CardContent, 
+  IconButton,
+  Typography,
+  Paper,
+  List,
+  ListItem,
+  ListItemText,
+} from '@mui/material';
+import PlayArrowIcon from '@mui/icons-material/PlayArrow';
+import PauseIcon from '@mui/icons-material/Pause';
+
+const generateDistinctColors = (count) => {
+  const colors = [];
+  const saturation = 65;
+  
+  for (let i = 0; i < count; i++) {
+    const hue = (i * 137.508) % 360;
+    colors.push({
+      light: `hsl(${hue}, ${saturation}%, 60%)`,
+      dark: `hsl(${hue}, ${saturation}%, 45%)`,
+      textLight: `hsl(${hue}, ${saturation}%, 95%)`,
+      textDark: `hsl(${hue}, ${saturation}%, 15%)`
+    });
+  }
+  return colors;
+};
+
+const TimelineTranscriptViewer = ({ 
+  clips,
+  transcriptData, 
+  viewMode,
+  timelineState
+}) => {
+  const [currentTime, setCurrentTime] = useState(0);
+  const [isPlaying, setIsPlaying] = useState(false);
+  const [selection, setSelection] = useState(null);
+  const [currentClipIndex, setCurrentClipIndex] = useState(0);
+  const videoRef = useRef(null);
+  const videoUrlRef = useRef(null);
+
+  // Generate colors based on number of clips
+  const clipColors = React.useMemo(() => 
+    generateDistinctColors(timelineState.clips.length),
+    [timelineState.clips.length]
+  );
+
+  // Sort clips by timeline position
+  const sortedClips = React.useMemo(() => {
+    return [...timelineState.clips].sort((a, b) => {
+      const aStart = a.metadata?.timeline?.start || 0;
+      const bStart = b.metadata?.timeline?.start || 0;
+      return aStart - bStart;
+    });
+  }, [timelineState.clips]);
+
+  useEffect(() => {
+    return () => {
+      if (videoUrlRef.current) {
+        URL.revokeObjectURL(videoUrlRef.current);
+      }
+    };
+  }, []);
+
+  useEffect(() => {
+    if (videoRef.current && sortedClips[currentClipIndex]?.file) {
+      if (videoUrlRef.current) {
+        URL.revokeObjectURL(videoUrlRef.current);
+      }
+      videoUrlRef.current = URL.createObjectURL(sortedClips[currentClipIndex].file);
+      videoRef.current.src = videoUrlRef.current;
+    }
+  }, [currentClipIndex, sortedClips]);
+
+  const handleTimeUpdate = useCallback(() => {
+    if (videoRef.current) {
+      setCurrentTime(videoRef.current.currentTime);
+    }
+  }, []);
+
+  const handleTogglePlay = useCallback(() => {
+    if (videoRef.current) {
+      if (isPlaying) {
+        videoRef.current.pause();
+      } else {
+        videoRef.current.play();
+      }
+      setIsPlaying(!isPlaying);
+    }
+  }, [isPlaying]);
+
+  const handleClipSelect = useCallback((index) => {
+    setCurrentClipIndex(index);
+    setSelection(null);
+    if (videoRef.current) {
+      videoRef.current.currentTime = 0;
+      setCurrentTime(0);
+    }
+  }, []);
+
+  const renderClipsList = () => (
+    <List sx={{ borderBottom: 1, borderColor: 'divider' }}>
+      {sortedClips.map((clip, index) => {
+        const timeline = clip.metadata?.timeline || {};
+        const playback = clip.metadata?.playback || {};
+        return (
+          <ListItem 
+            key={clip.id}
+            button
+            selected={index === currentClipIndex}
+            onClick={() => handleClipSelect(index)}
+          >
+            <ListItemText
+              primary={`Clip ${index + 1}`}
+              secondary={`Timeline: ${timeline.start?.toFixed(1)}s - ${timeline.end?.toFixed(1)}s | Source: ${playback.start?.toFixed(1)}s - ${playback.end?.toFixed(1)}s`}
+            />
+          </ListItem>
+        );
+      })}
+    </List>
+  );
+
+  const renderTranscript = () => {
+    if (!transcriptData || !(transcriptData instanceof Map)) {
+      return <Typography>No transcript data available</Typography>;
+    }
+
+    const transcriptEntry = Array.from(transcriptData.values())[0];
+    if (!transcriptEntry?.transcription) return null;
+
+    return (
+      <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
+        {sortedClips.map((clip, clipIndex) => {
+          const timeline = clip.metadata?.timeline || {};
+          const playback = clip.metadata?.playback || {};
+          const clipColor = clipColors[clipIndex];
+          const isCurrentClip = clipIndex === currentClipIndex;
+
+          // Filter words that belong to this clip's playback range
+          const clipWords = {};
+          transcriptEntry.transcription.forEach(segment => {
+            const speakerWords = segment.words.filter(word => 
+              word.start >= playback.start && word.end <= playback.end
+            );
+            
+            if (speakerWords.length > 0) {
+              if (!clipWords[segment.segment.speaker]) {
+                clipWords[segment.segment.speaker] = [];
+              }
+              clipWords[segment.segment.speaker].push(...speakerWords);
+            }
+          });
+
+          if (Object.keys(clipWords).length === 0) return null;
+
+          return (
+            <Paper
+              key={clip.id}
+              elevation={2}
+              sx={{
+                p: 2,
+                border: '1px solid',
+                borderColor: 'divider',
+                borderLeft: 4,
+                borderLeftColor: clipColor.light
+              }}
+            >
+              <Typography variant="subtitle2" sx={{ mb: 1, opacity: 0.7 }}>
+                Clip {clipIndex + 1}: Timeline [{timeline.start?.toFixed(1)}s - {timeline.end?.toFixed(1)}s]
+                {' '}| Source [{playback.start?.toFixed(1)}s - {playback.end?.toFixed(1)}s]
+              </Typography>
+
+              {Object.entries(clipWords).map(([speaker, words]) => (
+                <Box key={`${clip.id}-${speaker}`} sx={{ mb: 2 }}>
+                  <Typography variant="subtitle2" color="primary" sx={{ mb: 0.5 }}>
+                    Speaker {speaker}
+                  </Typography>
+                  <Typography variant="body2" sx={{ lineHeight: 1.8 }}>
+                    {words.map((word, wordIndex) => {
+                      const adjustedTime = word.start - playback.start;
+                      const isCurrentWord = isCurrentClip && 
+                        currentTime >= adjustedTime && 
+                        currentTime < (adjustedTime + (word.end - word.start));
+
+                      return (
+                        <Box
+                          component="span"
+                          key={`${word.word}-${wordIndex}`}
+                          onClick={() => videoRef.current && (videoRef.current.currentTime = word.start)}
+                          sx={{
+                            cursor: 'pointer',
+                            px: 0.5,
+                            py: 0.25,
+                            mx: 0.25,
+                            borderRadius: 1,
+                            transition: 'all 0.2s ease',
+                            bgcolor: isCurrentWord ? clipColor.dark : clipColor.light,
+                            color: isCurrentWord ? clipColor.textLight : clipColor.textDark,
+                            '&:hover': {
+                              bgcolor: clipColor.dark,
+                              color: clipColor.textLight
+                            }
+                          }}
+                        >
+                          {word.word}{' '}
+                        </Box>
+                      );
+                    })}
+                  </Typography>
+                </Box>
+              ))}
+            </Paper>
+          );
+        })}
+      </Box>
+    );
+  };
+
+  const renderContent = () => {
+    if (viewMode === 'video') {
+      return (
+        <Box sx={{ position: 'relative', aspectRatio: '16/9', bgcolor: 'black' }}>
+          {sortedClips[currentClipIndex] ? (
+            <>
+              <video
+                ref={videoRef}
+                style={{ width: '100%', height: '100%' }}
+                onTimeUpdate={handleTimeUpdate}
+                onPlay={() => setIsPlaying(true)}
+                onPause={() => setIsPlaying(false)}
+              />
+              <IconButton
+                sx={{
+                  position: 'absolute',
+                  bottom: 16,
+                  left: 16,
+                  bgcolor: 'rgba(255, 255, 255, 0.1)',
+                  '&:hover': { bgcolor: 'rgba(255, 255, 255, 0.2)' }
+                }}
+                onClick={handleTogglePlay}
+              >
+                {isPlaying ? <PauseIcon /> : <PlayArrowIcon />}
+              </IconButton>
+            </>
+          ) : (
+            <Typography variant="body2" color="text.secondary">
+              No clip selected
+            </Typography>
+          )}
+        </Box>
+      );
+    }
+    
+    return (
+      <Box sx={{ flexGrow: 1, overflowY: 'auto', p: 2 }}>
+        {renderTranscript()}
+      </Box>
+    );
+  };
+
+  return (
+    <Card sx={{ height: '100%', display: 'flex', flexDirection: 'column' }}>
+      <CardContent sx={{ p: 0, flexGrow: 1, display: 'flex', flexDirection: 'column' }}>
+        {renderClipsList()}
+        {renderContent()}
+        
+        {selection && (
+          <Paper 
+            elevation={3}
+            sx={{ 
+              p: 2,
+              m: 2,
+              mt: 'auto',
+              display: 'flex',
+              alignItems: 'center',
+              justifyContent: 'space-between',
+              bgcolor: 'background.paper'
+            }}
+          >
+            <Typography variant="body2">
+              <Box component="span" sx={{ fontWeight: 500 }}>Selected: </Box>
+              {selection.start.toFixed(2)}s - {selection.end.toFixed(2)}s
+            </Typography>
+          </Paper>
+        )}
+      </CardContent>
+    </Card>
+  );
+};
+
+export default TimelineTranscriptViewer;
\ No newline at end of file
diff --git a/src/components/Viewers/TimelineTranscriptViewerSection.js b/src/components/Viewers/TimelineTranscriptViewerSection.js
new file mode 100644
index 0000000..ca37b64
--- /dev/null
+++ b/src/components/Viewers/TimelineTranscriptViewerSection.js
@@ -0,0 +1,16 @@
+import React from 'react';
+import { Paper } from '@mui/material';
+import TimelineTranscriptViewer from './TimelineTranscriptViewer';
+
+const TimelineTranscriptViewerSection = ({ selectedClip, transcriptData }) => {
+  return (
+    <Paper sx={{ flex: 1, p: 2, bgcolor: 'background.paper' }}>
+      <TranscriptViewer
+        selectedClip={selectedClip}  // Pass the whole selectedClip object
+        transcriptData={transcriptData}
+      />
+    </Paper>
+  );
+};
+
+export default TimelineTranscriptViewerSection;
\ No newline at end of file
diff --git a/src/components/Viewers/TimelineViewer.js b/src/components/Viewers/TimelineViewer.js
new file mode 100644
index 0000000..adb2a4f
--- /dev/null
+++ b/src/components/Viewers/TimelineViewer.js
@@ -0,0 +1,222 @@
+import React, { useEffect, useRef, useState, useCallback } from 'react';
+import { Player } from 'video-react';
+import 'video-react/dist/video-react.css';
+import { Box, Button } from '@mui/material';
+import { PlayCircle, PauseCircle, SkipBack } from 'lucide-react';
+
+const TimelineViewer = ({ clips = [] }) => {
+  const [timelineTime, setTimelineTime] = useState(0);
+  const [isPlaying, setIsPlaying] = useState(false);
+  const playerRef = useRef(null);
+  const rafRef = useRef(null);
+  const lastTimeRef = useRef(0);
+  const currentClipRef = useRef(null);
+
+  // Calculate total timeline duration
+  const duration = clips.reduce((max, clip) => {
+    const end = clip.metadata?.timeline?.end || (clip.startTime + clip.duration);
+    return Math.max(max, end);
+  }, 0);
+
+  // Get active clip and source time for current timeline position
+  const getActiveClip = useCallback((time) => {
+    for (const clip of clips) {
+      const timelineStart = clip.metadata?.timeline?.start || 0;
+      const timelineEnd = clip.metadata?.timeline?.end || (timelineStart + clip.duration);
+      
+      if (time >= timelineStart && time <= timelineEnd) {
+        const clipProgress = (time - timelineStart) / (timelineEnd - timelineStart);
+        const sourceTime = clip.startTime + (clipProgress * (clip.endTime - clip.startTime));
+        
+        return {
+          clip,
+          sourceTime,
+          timelineStart,
+          timelineEnd
+        };
+      }
+    }
+    return null;
+  }, [clips]);
+
+  // Handle timeline playback
+  useEffect(() => {
+    if (!isPlaying) return;
+
+    const animate = () => {
+      const now = performance.now();
+      const delta = (now - lastTimeRef.current) / 1000;
+      lastTimeRef.current = now;
+
+      setTimelineTime(prevTime => {
+        const newTime = prevTime + delta;
+        if (newTime >= duration) {
+          setIsPlaying(false);
+          return 0;
+        }
+        return newTime;
+      });
+
+      rafRef.current = requestAnimationFrame(animate);
+    };
+
+    lastTimeRef.current = performance.now();
+    rafRef.current = requestAnimationFrame(animate);
+
+    return () => {
+      if (rafRef.current) {
+        cancelAnimationFrame(rafRef.current);
+      }
+    };
+  }, [isPlaying, duration]);
+
+  // Handle video playback and seeking
+  useEffect(() => {
+    if (!playerRef.current) return;
+
+    const activeClip = getActiveClip(timelineTime);
+    const player = playerRef.current;
+    
+    if (activeClip) {
+      // Only seek if changing clips
+      if (!currentClipRef.current || currentClipRef.current.clip.id !== activeClip.clip.id) {
+        console.log('Changing clip, seeking to:', activeClip.sourceTime);
+        player.seek(activeClip.sourceTime);
+        currentClipRef.current = activeClip;
+      }
+
+      if (isPlaying && player.getState().player.paused) {
+        player.play();
+      }
+    } else {
+      player.pause();
+      currentClipRef.current = null;
+    }
+  }, [timelineTime, getActiveClip, isPlaying]);
+
+  // Monitor playback and handle clip transitions
+  useEffect(() => {
+    if (!playerRef.current) return;
+
+    const handleStateChange = (state) => {
+      if (!currentClipRef.current) return;
+
+      const activeClip = currentClipRef.current;
+      if (state.currentTime >= activeClip.clip.endTime) {
+        playerRef.current.pause();
+        
+        // Find next clip if available
+        const nextClipInfo = getActiveClip(activeClip.timelineEnd + 0.1);
+        if (nextClipInfo) {
+          playerRef.current.seek(nextClipInfo.sourceTime);
+          currentClipRef.current = nextClipInfo;
+          if (isPlaying) {
+            playerRef.current.play();
+          }
+        }
+      }
+    };
+
+    playerRef.current.subscribeToStateChange(handleStateChange);
+  }, [isPlaying, getActiveClip]);
+
+  const handlePlay = () => {
+    const activeClip = getActiveClip(timelineTime);
+    if (activeClip) {
+      if (!currentClipRef.current || currentClipRef.current.clip.id !== activeClip.clip.id) {
+        playerRef.current.seek(activeClip.sourceTime);
+        currentClipRef.current = activeClip;
+      }
+    }
+    setIsPlaying(true);
+  };
+
+  const handlePause = () => {
+    setIsPlaying(false);
+    if (rafRef.current) {
+      cancelAnimationFrame(rafRef.current);
+    }
+    playerRef.current?.pause();
+  };
+
+  const handleReset = () => {
+    setIsPlaying(false);
+    setTimelineTime(0);
+    if (rafRef.current) {
+      cancelAnimationFrame(rafRef.current);
+    }
+    
+    const firstClip = getActiveClip(0);
+    if (firstClip) {
+      currentClipRef.current = firstClip;
+      playerRef.current?.seek(firstClip.sourceTime);
+    }
+  };
+
+  const formatTime = (seconds) => {
+    const mins = Math.floor(seconds / 60);
+    const secs = Math.floor(seconds % 60);
+    const ms = Math.floor((seconds % 1) * 100);
+    return `${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
+  };
+
+  if (!clips.length) {
+    return <div>No clips loaded</div>;
+  }
+
+  return (
+    <Box sx={{ width: '100%', height: '100%' }}>
+      <Box sx={{
+        '& .video-react-control-bar': {
+          display: 'none !important'
+        }
+      }}>
+        <Player
+          ref={playerRef}
+          autoPlay={false}
+          fluid={true}
+          playsInline
+          startTime={clips[0].startTime}
+        >
+          <source src={URL.createObjectURL(clips[0].file)} />
+        </Player>
+      </Box>
+
+      <Box sx={{ mt: 2, display: 'flex', alignItems: 'center', gap: 2 }}>
+        <Button 
+          onClick={isPlaying ? handlePause : handlePlay}
+          startIcon={isPlaying ? <PauseCircle /> : <PlayCircle />}
+        >
+          {isPlaying ? 'Pause' : 'Play'}
+        </Button>
+        
+        <Button 
+          onClick={handleReset}
+          startIcon={<SkipBack />}
+        >
+          Reset
+        </Button>
+
+        <Box sx={{ flex: 1, p: 2, bgcolor: 'background.paper' }}>
+          Timeline: {formatTime(timelineTime)} / {formatTime(duration)}
+        </Box>
+      </Box>
+
+      <Box sx={{ mt: 2, p: 2, bgcolor: 'background.paper' }}>
+        <pre>
+          {JSON.stringify({
+            timelineTime,
+            activeClip: getActiveClip(timelineTime) ? {
+              id: getActiveClip(timelineTime).clip.id,
+              timelineStart: getActiveClip(timelineTime).timelineStart,
+              timelineEnd: getActiveClip(timelineTime).timelineEnd,
+              sourceTime: getActiveClip(timelineTime).sourceTime
+            } : null
+          }, null, 2)}
+        </pre>
+      </Box>
+    </Box>
+  );
+};
+
+export default TimelineViewer;
\ No newline at end of file
diff --git a/src/components/Viewers/TimelineViewerSection.js b/src/components/Viewers/TimelineViewerSection.js
index ff822d7..4f6ca03 100644
--- a/src/components/Viewers/TimelineViewerSection.js
+++ b/src/components/Viewers/TimelineViewerSection.js
@@ -1,11 +1,63 @@
 // src/components/Viewers/TimelineViewerSection.js
-import React from 'react';
-import { Paper } from '@mui/material';
-import TimelineViewer from '../TimelineViewer';
-const TimelineViewerSection = ({ clips }) => {
+import React, { useState } from 'react';
+import { Box, Paper, ToggleButtonGroup, ToggleButton } from '@mui/material';
+import { FileVideo, FileText } from 'lucide-react';
+import TimelineViewer from './TimelineViewer';
+import TimelineTranscriptViewer from './TimelineTranscriptViewer';
+
+const TimelineViewerSection = ({ clips, currentClip, transcript,timelineState }) => {
+  const [viewMode, setViewMode] = useState('video');
+  
   return (
-    <Paper sx={{ flex: 1, p: 2, bgcolor: 'background.paper' }}>
-      <TimelineViewer clips={clips} />
+    <Paper sx={{ 
+      flex: 1, 
+      display: 'flex', 
+      flexDirection: 'column',
+      bgcolor: 'background.paper',
+      overflow: 'hidden'
+    }}>
+      <Box sx={{ 
+        p: 2, 
+        borderBottom: 1, 
+        borderColor: 'divider',
+        display: 'flex',
+        alignItems: 'center',
+        justifyContent: 'space-between'
+      }}>
+        <Box sx={{ typography: 'subtitle1' }}>Timeline Viewer</Box>
+        <ToggleButtonGroup
+          value={viewMode}
+          exclusive
+          onChange={(e, newMode) => newMode && setViewMode(newMode)}
+          size="small"
+        >
+          <ToggleButton value="video">
+            <FileVideo className="w-4 h-4 mr-2" />
+            Video
+          </ToggleButton>
+          <ToggleButton value="transcript">
+            <FileText className="w-4 h-4 mr-2" />
+            Transcript
+          </ToggleButton>
+        </ToggleButtonGroup>
+      </Box>
+
+      <Box sx={{ flex: 1, position: 'relative' }}>
+        {viewMode === 'video' ? (
+          <TimelineViewer
+            clips={clips}
+            currentClip={currentClip}
+          />
+        ) : (
+          <TimelineTranscriptViewer
+            key={clips.length} // Force refresh when clips array changes
+            clips={clips}
+            currentClip={currentClip}
+            transcriptData={transcript}
+            timelineState={timelineState}
+          />
+        )}
+      </Box>
     </Paper>
   );
 };
diff --git a/src/components/Viewers/TranscriptViewer.js b/src/components/Viewers/TranscriptViewer.js
new file mode 100644
index 0000000..b25210d
--- /dev/null
+++ b/src/components/Viewers/TranscriptViewer.js
@@ -0,0 +1,298 @@
+import React, { useState, useCallback, useEffect, useRef } from 'react';
+import { 
+  Box,
+  Card, 
+  CardContent, 
+  Button, 
+  Typography,
+  Paper
+} from '@mui/material';
+import AddIcon from '@mui/icons-material/Add';
+
+const TranscriptViewer = ({ 
+  selectedClip,
+  transcriptData, 
+  onAddToTimeline,
+  timelineRows,
+  setTimelineRows,
+  sx
+}) => {
+  const [currentTime, setCurrentTime] = useState(0);
+  const [selection, setSelection] = useState(null);
+  const videoRef = useRef(null);
+  const videoUrlRef = useRef(null);
+  
+  // Update useEffect to use selectedClip.file
+  useEffect(() => {
+    if (videoRef.current && selectedClip?.file) {
+      if (videoUrlRef.current) {
+        URL.revokeObjectURL(videoUrlRef.current);
+      }
+      videoUrlRef.current = URL.createObjectURL(selectedClip.file);
+      videoRef.current.src = videoUrlRef.current;
+    }
+  }, [selectedClip]);
+
+  const handleWordSelection = useCallback((startWord, endWord, text) => {
+    setSelection({
+      start: startWord.start,
+      end: endWord.end,
+      text,
+      startWord,
+      endWord
+    });
+  }, []);
+
+
+
+  const handleWordClick = useCallback((time) => {
+    if (videoRef.current) {
+      videoRef.current.currentTime = time;
+      setCurrentTime(time);
+    }
+  }, []);
+
+  const handleTextSelection = useCallback(() => {
+    const selection = window.getSelection();
+    if (!selection.rangeCount) return;
+  
+    const range = selection.getRangeAt(0);
+    const startNode = range.startContainer.parentNode;
+    const endNode = range.endContainer.parentNode;
+  
+    if (startNode.hasAttribute('data-time') && endNode.hasAttribute('data-time')) {
+      const startTime = parseFloat(startNode.getAttribute('data-time'));
+      const endTime = parseFloat(endNode.getAttribute('data-time-end'));
+  
+      // Find all words between start and end time
+      const allWords = transcriptData.transcription
+        .flatMap(item => item.words)
+        .filter(word => word.start >= startTime && word.end <= endTime);
+
+      if (allWords.length > 0) {
+        const startWord = allWords[0];
+        const endWord = allWords[allWords.length - 1];
+        
+        handleWordSelection(startWord, endWord, selection.toString());
+      }
+    }
+  }, [transcriptData, handleWordSelection]);
+
+
+  const handleAddToTimeline = useCallback(() => {
+    if (!selection || !selectedClip) {
+      console.warn('Missing required data for timeline clip', { selection, selectedClip });
+      return;
+    }
+  
+    // Create a video element to get duration
+    const video = document.createElement('video');
+    video.src = URL.createObjectURL(selectedClip.file);
+  
+    // Wait for metadata to load to get duration
+    video.addEventListener('loadedmetadata', () => {
+      const clipStart = selection.start;
+      const clipEnd = selection.end;
+      const timelineDuration = clipEnd - clipStart;
+      
+      // Find a suitable row for the new clip
+      const findSuitableRow = (startTime, endTime) => {
+        // First try to find an existing row where the clip can fit
+        let rowIndex = timelineRows.findIndex(row => {
+          // Check for overlaps with existing clips in this row
+          const hasOverlap = row.clips.some(clip => {
+            const clipTimelineStart = clip.metadata.timeline.start;
+            const clipTimelineEnd = clip.metadata.timeline.end;
+            return !(endTime <= clipTimelineStart || startTime >= clipTimelineEnd);
+          });
+          return !hasOverlap;
+        });
+    
+        // If no suitable row found, create a new one
+        if (rowIndex === -1) {
+          rowIndex = timelineRows.length;
+          setTimelineRows(prev => [...prev, { rowId: rowIndex, clips: [], lastEnd: 0 }]);
+        }
+    
+        return rowIndex;
+      };
+    
+      // Calculate where this clip should start in the timeline
+      const timelineStart = timelineRows[0]?.lastEnd || 0;
+      const timelineEnd = timelineStart + timelineDuration;
+      
+      // Find suitable row for the clip
+      const rowIndex = findSuitableRow(timelineStart, timelineEnd);
+      
+      const clipData = {
+        id: `clip-${Date.now()}`,
+        file: selectedClip.file,
+        name: selectedClip.file.name,
+        startTime: clipStart,
+        endTime: clipEnd,
+        duration: timelineDuration,
+        source: {
+          startTime: 0,
+          endTime: video.duration,
+          duration: video.duration
+        },
+        transcript: selection.text,
+        metadata: {
+          timeline: {
+            start: timelineStart,
+            end: timelineEnd,
+            duration: timelineDuration,
+            row: rowIndex // Include row information
+          },
+          playback: {
+            start: clipStart,
+            end: clipEnd,
+            duration: timelineDuration
+          }
+        },
+        selectionInfo: {
+          text: selection.text,
+          startWord: selection.startWord,
+          endWord: selection.endWord,
+          timeRange: {
+            start: clipStart,
+            end: clipEnd
+          }
+        }
+      };
+  
+      // Update the row's metadata
+      setTimelineRows(prev => {
+        const updated = [...prev];
+        const targetRow = updated[rowIndex];
+        targetRow.clips.push(clipData);
+        targetRow.lastEnd = Math.max(targetRow.lastEnd, timelineEnd);
+        return updated;
+      });
+  
+      // Cleanup
+      video.src = '';
+      URL.revokeObjectURL(video.src);
+  
+      console.log('Adding clip from transcript selection:', {
+        clipData,
+        selection,
+        timeline: clipData.metadata.timeline,
+        playback: clipData.metadata.playback,
+        rowIndex
+      });
+  
+      onAddToTimeline?.(clipData);
+      setSelection(null);
+    });
+  
+  }, [selection, selectedClip, onAddToTimeline, timelineRows, setTimelineRows]);
+
+  const renderTranscript = () => {
+    if (!transcriptData?.transcription) {
+      return (
+        <Box sx={{ 
+          display: 'flex', 
+          alignItems: 'center', 
+          justifyContent: 'center', 
+          height: '100%',
+          color: 'text.secondary' 
+        }}>
+          No transcript data available
+        </Box>
+      );
+    }
+  
+    return transcriptData.transcription.map((item, index) => (
+      <Box key={`segment-${index}`} sx={{ mb: 2 }}>
+        <Typography 
+          variant="subtitle2" 
+          color="primary"
+          sx={{ mb: 0.5, fontWeight: 500 }}
+        >
+          Speaker {item.segment.speaker}
+        </Typography>
+        <Box sx={{ fontSize: '0.875rem', lineHeight: 1.75 }}>
+          {item.words.map((word, wordIndex) => (
+            <Box
+              component="span"
+              key={`word-${wordIndex}`}
+              data-time={word.start}
+              data-time-end={word.end}
+              onClick={() => handleWordClick(word.start)}
+              sx={{
+                cursor: 'pointer',
+                px: 0.5,
+                borderRadius: 0.5,
+                transition: 'background-color 0.2s',
+                bgcolor: currentTime >= word.start && currentTime < word.end 
+                  ? 'primary.main' 
+                  : selection?.start === word.start || selection?.end === word.end
+                  ? 'primary.dark'
+                  : selection?.start <= word.start && selection?.end >= word.end
+                  ? 'primary.light'
+                  : 'transparent',
+                color: (currentTime >= word.start && currentTime < word.end) ||
+                      (selection?.start <= word.start && selection?.end >= word.end)
+                  ? 'primary.contrastText' 
+                  : 'inherit',
+                '&:hover': {
+                  bgcolor: 'action.hover'
+                }
+              }}
+            >
+              {word.word}{' '}
+            </Box>
+          ))}
+        </Box>
+      </Box>
+    ));
+  };
+
+  return (
+    <Card sx={{ height: '100%', display: 'flex', flexDirection: 'column', ...sx }}>
+      <CardContent sx={{ p: 0, flexGrow: 1, display: 'flex', flexDirection: 'column' }}>
+        <Box 
+          sx={{ 
+            flexGrow: 1,
+            height: 400,
+            overflowY: 'auto',
+            p: 2
+          }}
+          onMouseUp={handleTextSelection}
+        >
+          {renderTranscript()}
+        </Box>
+
+        {selection && (
+          <Paper
+            elevation={3}
+            sx={{
+              p: 2,
+              display: 'flex',
+              alignItems: 'center',
+              justifyContent: 'space-between',
+              borderTop: 1,
+              borderColor: 'divider',
+              bgcolor: 'background.default'
+            }}
+          >
+            <Typography variant="body2">
+              <Box component="span" sx={{ fontWeight: 500 }}>Selected: </Box>
+              {selection.start.toFixed(2)}s - {selection.end.toFixed(2)}s
+            </Typography>
+            <Button
+              variant="contained"
+              onClick={handleAddToTimeline}
+              startIcon={<AddIcon />}
+            >
+              Add to Timeline
+            </Button>
+          </Paper>
+        )}
+      </CardContent>
+    </Card>
+  );
+};
+
+export default TranscriptViewer;
\ No newline at end of file
diff --git a/src/components/Viewers/TranscriptViewerSection.js b/src/components/Viewers/TranscriptViewerSection.js
new file mode 100644
index 0000000..589e5dd
--- /dev/null
+++ b/src/components/Viewers/TranscriptViewerSection.js
@@ -0,0 +1,26 @@
+import React from 'react';
+import { Paper } from '@mui/material';
+import TranscriptViewer from './TranscriptViewer';
+
+const TranscriptViewerSection = ({ selectedClip, transcriptData, onAddToTimeline }) => {
+    useEffect(() => {
+        console.log('TranscriptViewerSection props updated:', {
+          selectedClip,
+          transcriptData,
+        });
+      }, [selectedClip, transcriptData]);
+    
+  return (
+    
+    <Paper sx={{ flex: 1, p: 2, bgcolor: 'background.paper' }}>
+      <TranscriptViewer
+        key={selectedClip?.id}
+        selectedClip={selectedClip}  // Pass the whole selectedClip object
+        transcriptData={transcriptData}
+        onAddToTimeline={onAddToTimeline}
+      />
+    </Paper>
+  );
+};
+
+export default TranscriptViewerSection;
\ No newline at end of file
diff --git a/src/hooks/useTimeline/index.js b/src/hooks/useTimeline/index.js
index e69de29..a9c4b82 100644
--- a/src/hooks/useTimeline/index.js
+++ b/src/hooks/useTimeline/index.js
@@ -0,0 +1,12 @@
+export { useTimelineData } from './useTimelineData';
+export { useTimelineEffects } from './useTimelineEffects';
+export { useTimelineStateManager } from './useTimelineStateManager';
+export { useTimelineTransition } from './useTimelineTransition';
+
+// You can also bundle them into an object if you want to namespace them
+export const useTimeline = {
+  data: useTimelineData,
+  effects: useTimelineEffects,
+  stateManager: useTimelineStateManager,
+  transition: useTimelineTransition
+};
\ No newline at end of file
diff --git a/src/hooks/useTimeline/useTimelineData.js b/src/hooks/useTimeline/useTimelineData.js
index a3abca7..5d59cf1 100644
--- a/src/hooks/useTimeline/useTimelineData.js
+++ b/src/hooks/useTimeline/useTimelineData.js
@@ -1,4 +1,12 @@
 import { useMemo, useState } from 'react';
+
+const formatTime = (seconds) => {
+  const mins = Math.floor(seconds / 60);
+  const secs = Math.floor(seconds % 60);
+  const ms = Math.floor((seconds % 1) * 100);
+  return `${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
+};
+
 export const useTimelineData = (clips = [], onClipsChange) => {
   const [error, setError] = useState(null);
 
@@ -26,88 +34,134 @@ export const useTimelineData = (clips = [], onClipsChange) => {
     }
   }), []);
 
-  const editorData = useMemo(() => {
+  const { editorData, timelineState } = useMemo(() => {
     try {
       let currentPosition = 0;
-      const rows = clips.map((clip, index) => {
-        // If clip has existing metadata from resize, use it directly
-        if (clip.metadata?.timeline && clip.metadata?.playback) {
-          return {
-            id: String(index),
-            actions: [{
-              id: clip.id,
-              start: clip.metadata.timeline.start,
-              end: clip.metadata.timeline.end,
-              effectId: 'default',
-              flexible: true,
-              movable: true,
-              data: clip  // Use existing clip data without recalculating
-            }]
-          };
-        }
-
-        // Otherwise calculate initial positions for new clips
-        const sourceStart = clip.source?.startTime ?? 0;
-        const sourceEnd = clip.source?.endTime ?? (sourceStart + (clip.duration || 0));
-        const sourceDuration = sourceEnd - sourceStart;
-
-        const timelineStart = currentPosition;
-        const timelineEnd = timelineStart + sourceDuration;
+      const clipsState = [];
+      const actionsByRow = new Map();
+      
+      clips.forEach((clip, index) => {
+        // Calculate clip timings
+        let timelineStart, timelineEnd, playbackStart, playbackEnd;
+        const rowIndex = clip.metadata?.timeline?.row ?? 0;
         
-        // Update position for next clip
-        if (!clip.hasBeenPositioned) {
-          currentPosition = timelineEnd + 0.1;
+        if (clip.metadata?.timeline && clip.metadata?.playback) {
+          timelineStart = clip.metadata.timeline.start;
+          timelineEnd = clip.metadata.timeline.end;
+          playbackStart = clip.metadata.playback.start;
+          playbackEnd = clip.metadata.playback.end;
+        } else {
+          timelineStart = currentPosition;
+          timelineEnd = timelineStart + clip.duration;
+          playbackStart = clip.startTime;
+          playbackEnd = clip.endTime;
+          
+          if (!clip.hasBeenPositioned) {
+            currentPosition = timelineEnd + 0.1;
+          }
         }
 
-        return {
-          id: String(index),
-          actions: [{
-            id: clip.id,
-            start: timelineStart,
-            end: timelineEnd,
-            effectId: 'default',
-            flexible: true,
-            movable: true,
-            data: {
-              ...clip,
-              hasBeenPositioned: true,
-              metadata: {
-                timeline: {
-                  start: timelineStart,
-                  end: timelineEnd,
-                  duration: timelineEnd - timelineStart
-                },
-                playback: {
-                  start: sourceStart,
-                  end: sourceEnd,
-                  duration: sourceDuration
-                }
+        const action = {
+          id: clip.id,
+          start: timelineStart,
+          end: timelineEnd,
+          effectId: 'default',
+          flexible: true,
+          movable: true,
+          data: {
+            ...clip,
+            hasBeenPositioned: true,
+            metadata: {
+              timeline: {
+                start: timelineStart,
+                end: timelineEnd,
+                duration: timelineEnd - timelineStart,
+                row: rowIndex
+              },
+              playback: {
+                start: playbackStart,
+                end: playbackEnd,
+                duration: playbackEnd - playbackStart
               }
             }
-          }]
+          }
         };
+
+        // Group actions by row
+        if (!actionsByRow.has(rowIndex)) {
+          actionsByRow.set(rowIndex, []);
+        }
+        actionsByRow.get(rowIndex).push(action);
+
+        clipsState.push({
+          id: clip.id,
+          name: clip.name || `Clip ${index + 1}`,
+          timelinePosition: formatTime(timelineStart),
+          row: rowIndex
+        });
       });
 
-      // Add empty row at the end
+      // Convert Map to array of row objects
+      const rows = Array.from(actionsByRow.entries())
+        .sort(([a], [b]) => a - b) // Sort by row index
+        .map(([rowIndex, actions]) => ({
+          id: `row-${rowIndex}`,
+          actions
+        }));
+
+      // Always ensure at least one row exists
+      if (rows.length === 0) {
+        rows.push({
+          id: 'row-0',
+          actions: []
+        });
+      }
+
+      // Add empty row at the end for new clips
       rows.push({
-        id: String(clips.length),
+        id: `row-${rows.length}`,
         actions: []
       });
 
-      return rows;
+      const timelineState = {
+        totalDuration: formatTime(currentPosition),
+        clips: clipsState,
+        settings: {
+          effects: Object.keys(effects),
+          snapToGrid: true,
+          autoScroll: true
+        }
+      };
+
+      return {
+        editorData: rows, // Return array of rows directly
+        timelineState
+      };
     } catch (err) {
       console.error('Error processing timeline data:', err);
       setError('Error processing timeline data: ' + err.message);
-      return [{
-        id: '0',
-        actions: []
-      }];
+      return {
+        editorData: [{
+          id: 'row-0',
+          actions: []
+        }],
+        timelineState: {
+          totalDuration: '0:00.00',
+          clips: [],
+          settings: {
+            effects: Object.keys(effects),
+            snapToGrid: true,
+            autoScroll: true
+          }
+        }
+      };
     }
-  }, [clips]);
+  }, [clips, effects]);
 
   return { 
-    editorData, 
+    editorData, // Now returns array directly
     effects, 
-    error
+    error,
+    timelineState
   };
 };
\ No newline at end of file
diff --git a/src/hooks/useTimeline/useTimelineStateManager.js b/src/hooks/useTimeline/useTimelineStateManager.js
new file mode 100644
index 0000000..787f573
--- /dev/null
+++ b/src/hooks/useTimeline/useTimelineStateManager.js
@@ -0,0 +1,233 @@
+import { useCallback } from 'react';
+
+export const useTimelineStateManager = ({
+  timelineClips,
+  timelineMetadata,
+  mediaFiles,
+  selectedClipId,
+  setTimelineClips,
+  setTimelineMetadata,
+  showNotification
+}) => {
+  const saveTimelineProject = useCallback((projectName) => {
+    const timelineProject = {
+      version: "2.0",
+      timestamp: new Date().toISOString(),
+      timeline: {
+        clips: timelineClips.map(clip => {
+          const metadata = clip.metadata || {};
+          const playback = metadata.playback || {};
+          const timeline = metadata.timeline || {};
+
+          return {
+            id: clip.id,
+            source: {
+              startTime: playback.start,
+              endTime: playback.end,
+              duration: clip.source?.duration,
+              name: clip.file.name
+            },
+            file: {
+              name: clip.file.name,
+              size: clip.file.size,
+              type: clip.file.type,
+              // Store blob data as base64 string
+              data: clip.file instanceof Blob ? 
+                new Promise(resolve => {
+                  const reader = new FileReader();
+                  reader.onloadend = () => resolve(reader.result);
+                  reader.readAsDataURL(clip.file);
+                }) : null
+            },
+            metadata: {
+              originalDuration: clip.source?.duration,
+              timeline: {
+                sourceStart: clip.source?.startTime,
+                sourceEnd: clip.source?.endTime,
+                start: timeline.start,
+                end: timeline.end,
+                duration: timeline.duration
+              },
+              playback: {
+                start: playback.start,
+                end: playback.end,
+                duration: playback.duration
+              }
+            },
+            position: {
+              timelineStart: timeline.start,
+              timelineEnd: timeline.end,
+              currentStart: playback.start,
+              currentEnd: playback.end,
+              track: timeline.track || 0
+            },
+            state: {
+              selected: clip.id === selectedClipId,
+              effectId: clip.effectId || 'default'
+            }
+          };
+        }),
+        duration: timelineMetadata.duration || 0,
+        settings: {
+          scale: timelineMetadata.scale || 1,
+          effects: timelineMetadata.effects || {}
+        }
+      }
+    };
+  
+    try {
+      const savedProjects = JSON.parse(localStorage.getItem('timelineProjects') || '{}');
+      savedProjects[projectName] = {
+        ...timelineProject,
+        lastModified: new Date().toISOString()
+      };
+      localStorage.setItem('timelineProjects', JSON.stringify(savedProjects));
+      showNotification(`Timeline project "${projectName}" saved successfully`, 'success');
+      return true;
+    } catch (error) {
+      console.error('Failed to save timeline project:', error);
+      showNotification('Failed to save timeline project', 'error');
+      return false;
+    }
+  }, [timelineClips, timelineMetadata, selectedClipId, showNotification]);
+
+  // Helper function to convert file data to File object
+  const createFileFromData = useCallback(async (fileData) => {
+    try {
+      // If we have base64 data
+      if (fileData.data) {
+        // Convert base64 to blob
+        const response = await fetch(fileData.data);
+        const blob = await response.blob();
+        return new File([blob], fileData.name, {
+          type: fileData.type,
+          lastModified: Date.now()
+        });
+      }
+      // If we have a mediaFile reference
+      else if (mediaFiles) {
+        const mediaFile = mediaFiles.find(f => f.name === fileData.name);
+        if (mediaFile?.data) {
+          const response = await fetch(mediaFile.data);
+          const blob = await response.blob();
+          return new File([blob], fileData.name, {
+            type: fileData.type,
+            lastModified: Date.now()
+          });
+        }
+      }
+      throw new Error(`No file data available for ${fileData.name}`);
+    } catch (error) {
+      console.error('Failed to create File:', error);
+      throw error;
+    }
+  }, [mediaFiles]);
+
+  const loadTimelineProject = useCallback(async (projectName) => {
+    try {
+      console.log('=== LOADING PROJECT START ===');
+      
+      if (!mediaFiles?.length) {
+        throw new Error('No media files available');
+      }
+
+      const savedProjects = JSON.parse(localStorage.getItem('timelineProjects') || '{}');
+      const project = savedProjects[projectName];
+      
+      if (!project) {
+        throw new Error(`Timeline project "${projectName}" not found`);
+      }
+
+      console.log('Loading project data:', project);
+
+      // Process clips sequentially to handle async file conversion
+      const loadedClips = [];
+      for (const clip of project.timeline.clips) {
+        try {
+          // Create File object from stored data
+          const fileObject = await createFileFromData(clip.file);
+          if (!fileObject) {
+            throw new Error(`Failed to create file for: ${clip.file.name}`);
+          }
+
+          const newClip = {
+            id: clip.id,
+            file: fileObject,
+            startTime: clip.metadata.playback.start,
+            endTime: clip.metadata.playback.end,
+            duration: clip.metadata.playback.duration,
+            metadata: {
+              timeline: {
+                start: clip.metadata.timeline.start,
+                end: clip.metadata.timeline.end,
+                duration: clip.metadata.timeline.duration
+              },
+              playback: {
+                start: clip.metadata.playback.start,
+                end: clip.metadata.playback.end,
+                duration: clip.metadata.playback.duration
+              }
+            },
+            source: {
+              startTime: clip.metadata.timeline.sourceStart,
+              endTime: clip.metadata.timeline.sourceEnd,
+              duration: clip.metadata.originalDuration
+            }
+          };
+
+          console.log('Created clip:', {
+            id: newClip.id,
+            startTime: newClip.startTime,
+            endTime: newClip.endTime,
+            file: {
+              name: newClip.file.name,
+              type: newClip.file.type,
+              isFile: newClip.file instanceof File
+            }
+          });
+
+          loadedClips.push(newClip);
+        } catch (error) {
+          console.error(`Failed to process clip ${clip.id}:`, error);
+          throw error;
+        }
+      }
+
+      console.log('Setting timeline clips:', loadedClips);
+      setTimelineClips(loadedClips);
+      setTimelineMetadata(prev => ({
+        ...prev,
+        scale: project.timeline.settings?.scale || 1
+      }));
+      
+      console.log('=== LOADING PROJECT COMPLETE ===');
+      showNotification(`Timeline project "${projectName}" loaded successfully`, 'success');
+      return true;
+    } catch (error) {
+      console.error('=== LOADING PROJECT ERROR ===');
+      console.error('Error details:', error);
+      showNotification(error.message, 'error');
+      return false;
+    }
+  }, [mediaFiles, setTimelineClips, setTimelineMetadata, showNotification, createFileFromData]);
+
+  const deleteTimelineProject = useCallback((projectName) => {
+    try {
+      const savedProjects = JSON.parse(localStorage.getItem('timelineProjects') || '{}');
+      delete savedProjects[projectName];
+      localStorage.setItem('timelineProjects', JSON.stringify(savedProjects));
+      showNotification(`Timeline project "${projectName}" deleted`, 'success');
+      return true;
+    } catch (error) {
+      console.error('Failed to delete timeline project:', error);
+      showNotification('Failed to delete timeline project', 'error');
+      return false;
+    }
+  }, [showNotification]);
+
+  return {
+    saveTimelineProject,
+    loadTimelineProject,
+    deleteTimelineProject
+  };
+};
\ No newline at end of file
diff --git a/src/hooks/useTimeline/useTimelineTransition.js b/src/hooks/useTimeline/useTimelineTransition.js
new file mode 100644
index 0000000..113ba8f
--- /dev/null
+++ b/src/hooks/useTimeline/useTimelineTransition.js
@@ -0,0 +1,59 @@
+import { useMemo, useCallback, useState, useEffect } from 'react';
+
+export const useTimelineTransition = (clips = [], currentTime, playing) => {
+  const [playbackStates, setPlaybackStates] = useState({});
+
+  // Track active clips based on timeline position
+  const activeClips = useMemo(() => {
+    return clips.filter(clip => {
+      if (!clip.metadata || !clip.metadata.timeline) {
+        console.warn('Clip is missing metadata or timeline:', clip);
+        return false; // Skip this clip
+      }
+      const { start, end } = clip.metadata.timeline;
+      return currentTime >= start && currentTime <= end;
+    }).sort((a, b) => a.metadata.timeline.start - b.metadata.timeline.start);
+  }, [clips, currentTime]);
+
+  // Calculate opacity for each clip based on overlap position
+  const getClipOpacity = useCallback((clip) => {
+    const { start, end } = clip.metadata.timeline;
+    const progress = (currentTime - start) / (end - start);
+    
+    // Fade in at start
+    if (progress < 0.1) {
+      return progress * 10;
+    }
+    // Fade out at end
+    if (progress > 0.9) {
+      return (1 - (progress - 0.9) * 10);
+    }
+    return 1;
+  }, [currentTime]);
+
+  // Calculate playback position for each clip
+  const getClipPlaybackPosition = useCallback((clip) => {
+    const { start } = clip.metadata.timeline;
+    return currentTime - start;
+  }, [currentTime]);
+
+  // Track playback state for each clip
+  useEffect(() => {
+    const newPlaybackStates = {};
+    activeClips.forEach(clip => {
+      newPlaybackStates[clip.id] = {
+        position: getClipPlaybackPosition(clip),
+        opacity: getClipOpacity(clip),
+        playing: playing && currentTime >= clip.metadata.timeline.start
+      };
+    });
+    setPlaybackStates(newPlaybackStates);
+  }, [activeClips, currentTime, playing, getClipPlaybackPosition, getClipOpacity]);
+
+  return {
+    activeClips,
+    playbackStates,
+    getClipOpacity,
+    getClipPlaybackPosition
+  };
+};
diff --git a/src/hooks/useTranscript.js b/src/hooks/useTranscript.js
new file mode 100644
index 0000000..ef63039
--- /dev/null
+++ b/src/hooks/useTranscript.js
@@ -0,0 +1,62 @@
+// hooks/useTranscript.js
+import { useState, useCallback } from 'react';
+
+export const useTranscript = () => {
+  const [transcripts, setTranscripts] = useState(new Map());
+  const [transcriptErrors, setTranscriptErrors] = useState(new Map());
+
+  const loadTranscript = useCallback(async (file, videoFileName) => {
+    try {
+      // Clear any previous errors for this file
+      setTranscriptErrors(prev => {
+        const next = new Map(prev);
+        next.delete(videoFileName);
+        return next;
+      });
+
+      const text = await file.text();
+      const data = JSON.parse(text);
+
+      // Validate transcript structure
+      if (!data.transcription) {
+        throw new Error('Invalid transcript format');
+      }
+
+      setTranscripts(prev => new Map(prev).set(videoFileName, data));
+      return true;
+    } catch (error) {
+      setTranscriptErrors(prev => new Map(prev).set(videoFileName, error.message));
+      return false;
+    }
+  }, []);
+
+  const getTranscript = useCallback((videoFileName) => {
+    return transcripts.get(videoFileName);
+  }, [transcripts]);
+
+  const getTranscriptError = useCallback((videoFileName) => {
+    return transcriptErrors.get(videoFileName);
+  }, [transcriptErrors]);
+
+  const clearTranscript = useCallback((videoFileName) => {
+    setTranscripts(prev => {
+      const next = new Map(prev);
+      next.delete(videoFileName);
+      return next;
+    });
+    setTranscriptErrors(prev => {
+      const next = new Map(prev);
+      next.delete(videoFileName);
+      return next;
+    });
+  }, []);
+
+  return {
+    transcripts,
+    transcriptErrors,
+    loadTranscript,
+    getTranscript,
+    getTranscriptError,
+    clearTranscript
+  };
+};
\ No newline at end of file
